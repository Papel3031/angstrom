/**

Generated by the following Solidity interface...
```solidity
interface PoolManager {
    type BalanceDelta is int256;
    type Currency is address;
    type PoolId is bytes32;
    struct ModifyLiquidityParams {
        int24 tickLower;
        int24 tickUpper;
        int256 liquidityDelta;
        bytes32 salt;
    }
    struct PoolKey {
        Currency currency0;
        Currency currency1;
        uint24 fee;
        int24 tickSpacing;
        address hooks;
    }
    struct SwapParams {
        bool zeroForOne;
        int256 amountSpecified;
        uint160 sqrtPriceLimitX96;
    }

    error AlreadyUnlocked();
    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);
    error CurrencyNotSettled();
    error DelegateCallNotAllowed();
    error InvalidCaller();
    error ManagerLocked();
    error MustClearExactPositiveDelta();
    error NonzeroNativeValue();
    error PoolNotInitialized();
    error ProtocolFeeCannotBeFetched();
    error ProtocolFeeTooLarge(uint24 fee);
    error SwapAmountCannotBeZero();
    error TickSpacingTooLarge(int24 tickSpacing);
    error TickSpacingTooSmall(int24 tickSpacing);
    error UnauthorizedDynamicLPFeeUpdate();

    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);
    event Initialize(PoolId indexed id, Currency indexed currency0, Currency indexed currency1, uint24 fee, int24 tickSpacing, address hooks, uint160 sqrtPriceX96, int24 tick);
    event ModifyLiquidity(PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt);
    event OperatorSet(address indexed owner, address indexed operator, bool approved);
    event OwnershipTransferred(address indexed user, address indexed newOwner);
    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);
    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
    event Swap(PoolId indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee);
    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);

    constructor(uint256 controllerGasLimit);

    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
    function approve(address spender, uint256 id, uint256 amount) external returns (bool);
    function balanceOf(address owner, uint256 id) external view returns (uint256 balance);
    function burn(address from, uint256 id, uint256 amount) external;
    function clear(Currency currency, uint256 amount) external;
    function collectProtocolFees(address recipient, Currency currency, uint256 amount) external returns (uint256 amountCollected);
    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData) external returns (BalanceDelta delta);
    function extsload(bytes32 slot) external view returns (bytes32);
    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory);
    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
    function exttload(bytes32[] memory slots) external view returns (bytes32[] memory);
    function exttload(bytes32 slot) external view returns (bytes32);
    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes memory hookData) external returns (int24 tick);
    function isOperator(address owner, address operator) external view returns (bool isOperator);
    function mint(address to, uint256 id, uint256 amount) external;
    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes memory hookData) external returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
    function owner() external view returns (address);
    function protocolFeeController() external view returns (address);
    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);
    function setOperator(address operator, bool approved) external returns (bool);
    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
    function setProtocolFeeController(address controller) external;
    function settle() external payable returns (uint256);
    function settleFor(address recipient) external payable returns (uint256);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function swap(PoolKey memory key, SwapParams memory params, bytes memory hookData) external returns (BalanceDelta swapDelta);
    function sync(Currency currency) external;
    function take(Currency currency, address to, uint256 amount) external;
    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
    function transferOwnership(address newOwner) external;
    function unlock(bytes memory data) external returns (bytes memory result);
    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "controllerGasLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "clear",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "collectProtocolFees",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "amountCollected",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "donate",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "amount0",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "delta",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "startSlot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "nSlots",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "exttload",
    "inputs": [
      {
        "name": "slots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "exttload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "sqrtPriceX96",
        "type": "uint160",
        "internalType": "uint160"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "tick",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isOperator",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "isOperator",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "modifyLiquidity",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "params",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "callerDelta",
        "type": "int256",
        "internalType": "BalanceDelta"
      },
      {
        "name": "feesAccrued",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolFeeController",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IProtocolFeeController"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolFeesAccrued",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      }
    ],
    "outputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFee",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "newProtocolFee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFeeController",
    "inputs": [
      {
        "name": "controller",
        "type": "address",
        "internalType": "contract IProtocolFeeController"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "settle",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "settleFor",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "swap",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "params",
        "type": "tuple",
        "internalType": "struct IPoolManager.SwapParams",
        "components": [
          {
            "name": "zeroForOne",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "amountSpecified",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "sqrtPriceLimitX96",
            "type": "uint160",
            "internalType": "uint160"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "swapDelta",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sync",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "take",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unlock",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateDynamicLPFee",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "newDynamicLPFee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Donate",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount0",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount1",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialize",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "currency0",
        "type": "address",
        "indexed": true,
        "internalType": "Currency"
      },
      {
        "name": "currency1",
        "type": "address",
        "indexed": true,
        "internalType": "Currency"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "hooks",
        "type": "address",
        "indexed": false,
        "internalType": "contract IHooks"
      },
      {
        "name": "sqrtPriceX96",
        "type": "uint160",
        "indexed": false,
        "internalType": "uint160"
      },
      {
        "name": "tick",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ModifyLiquidity",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tickLower",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "tickUpper",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "liquidityDelta",
        "type": "int256",
        "indexed": false,
        "internalType": "int256"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSet",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFeeControllerUpdated",
    "inputs": [
      {
        "name": "protocolFeeController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFeeUpdated",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "protocolFee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Swap",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount0",
        "type": "int128",
        "indexed": false,
        "internalType": "int128"
      },
      {
        "name": "amount1",
        "type": "int128",
        "indexed": false,
        "internalType": "int128"
      },
      {
        "name": "sqrtPriceX96",
        "type": "uint160",
        "indexed": false,
        "internalType": "uint160"
      },
      {
        "name": "liquidity",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      },
      {
        "name": "tick",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyUnlocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CurrenciesOutOfOrderOrEqual",
    "inputs": [
      {
        "name": "currency0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currency1",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CurrencyNotSettled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DelegateCallNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCaller",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ManagerLocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MustClearExactPositiveDelta",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NonzeroNativeValue",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PoolNotInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProtocolFeeCannotBeFetched",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProtocolFeeTooLarge",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ]
  },
  {
    "type": "error",
    "name": "SwapAmountCannotBeZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TickSpacingTooLarge",
    "inputs": [
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ]
  },
  {
    "type": "error",
    "name": "TickSpacingTooSmall",
    "inputs": [
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnauthorizedDynamicLPFeeUpdate",
    "inputs": []
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod PoolManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60c034609d57601f615e3338819003918201601f19168301916001600160401b0383118484101760a157808492602094604052833981010312609d57515f80546001600160a01b03191633908117825560405192917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a36080523060a052615d7d90816100b6823960805181611284015260a051816135fd0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60a0806040526004361015610012575f80fd5b5f3560e01c908162fdd58e14612d885750806301ffc9a714612cc9578063095bcdb614612c1f5780630b0d9c0914612b9357806311da60b414612b38578063156e29f614612a885780631e2eaeaf14612a4e578063234266d7146127af5780632d771389146126ed57806335fd631a146126795780633dd45adb14612615578063426a84931461259157806348c894911461230657806352759651146121ee578063558a729714612117578063598af9e71461207f5780635a6bcfda1461153d578063695c5bf514610eac5780637e87ce7d14610d6f57806380f0b44c14610c9f5780638161b87414610ba75780638da5cb5b14610b5757806397e8cd4e14610af45780639bf6645f14610aa7578063a584119414610a66578063b6363cf2146109d5578063dbd035ff1461097f578063f02de3b21461092e578063f135baaa146108f4578063f2fde38b14610848578063f3cd914c146104ff578063f5298aca146103345763fe99049a14610186575f80fd5b346103305760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576101bd612df2565b6101c5612e15565b90604435917f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885961027973ffffffffffffffffffffffffffffffffffffffff80606435951693843314158061030d575b610287575b845f52600460205260405f20875f5260205260405f2061023a8782546130a0565b90551693845f52600460205260405f20865f5260205260405f2061025f8282546130ad565b905560408051338152602081019290925290918291820190565b0390a4602060405160018152f35b845f52600560205260405f208233165f5260205260405f20875f5260205260405f2054867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102da575b5050610219565b6102e3916130a0565b855f52600560205260405f208333165f5260205260405f20885f5260205260405f20555f866102d3565b50845f52600360205260405f208233165f5260205260ff60405f20541615610214565b5f80fd5b346103305761034236612e38565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ed73ffffffffffffffffffffffffffffffffffffffff805f9516956103bb6103b386613233565b339089613279565b169233841415806104a0575b6103f2575b8385526004602052604085208686526020526040852061025f8282546130a0565b0390a4005b83855260056020526040852073ffffffffffffffffffffffffffffffffffffffff33168652602052604085208686526020526040852054817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610459575b50506103cc565b610462916130a0565b84865260056020526040862073ffffffffffffffffffffffffffffffffffffffff331687526020526040862087875260205260408620558681610452565b5083855260036020526040852073ffffffffffffffffffffffffffffffffffffffff3316865260205260ff604086205416156103c7565b7f54e3ca0d000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761053836612f34565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c360112610330576040519061056f82612ea9565b60a4358015158103610330578252602082019060c435825260e4359073ffffffffffffffffffffffffffffffffffffffff8216820361033057604084019182526101043567ffffffffffffffff8111610330576105d0903690600401613000565b9290937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576106026135e6565b51156108205760a0822092835f52600660205260405f20906106238261364d565b60808401958482828a8a5173ffffffffffffffffffffffffffffffffffffffff169361064e94613c1b565b90949195606088015160020b968b511515915173ffffffffffffffffffffffffffffffffffffffff1691604051986106858a612ec5565b895260208901526040880152606087015262ffffff166080860152885115155f149862ffffff6107a2986106db61078f9860209d6108005773ffffffffffffffffffffffffffffffffffffffff8b511695614967565b9492968291926107d3575b505073ffffffffffffffffffffffffffffffffffffffff845116938e6fffffffffffffffffffffffffffffffff60408301511691015160020b90604051958860801d600f0b875288600f0b60208801526040870152606086015260808501521660a08301527f40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f60c03393a38673ffffffffffffffffffffffffffffffffffffffff8a5116613e58565b809491946107aa575b5050823391613729565b604051908152f35b73ffffffffffffffffffffffffffffffffffffffff6107cc9251169083613729565b8480610798565b73ffffffffffffffffffffffffffffffffffffffff165f5260018f5260405f209081540190558e806106e6565b73ffffffffffffffffffffffffffffffffffffffff8e8c01511695614967565b7fbe8b8507000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fffffffffffffffffffffffff00000000000000000000000000000000000000006108a0612df2565b73ffffffffffffffffffffffffffffffffffffffff5f54916108c582841633146130ba565b1691829116175f55337f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004355c5f5260205ff35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b346103305761098d3661302e565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355481520191019084838210156109cc5750602080916109b0565b60408186030190f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610a0c612df2565b73ffffffffffffffffffffffffffffffffffffffff610a29612e15565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060ff60405f2054166040519015158152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610aa5610aa0612df2565b61315d565b005b3461033057610ab53661302e565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355c81520191019084838210156109cc575060208091610ad8565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305773ffffffffffffffffffffffffffffffffffffffff610b40612df2565b165f526001602052602060405f2054604051908152f35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610bde612df2565b610be6612e15565b9060443573ffffffffffffffffffffffffffffffffffffffff600254163303610c77576020926107a29180610c6f575073ffffffffffffffffffffffffffffffffffffffff81165f526001845260405f20549283915b73ffffffffffffffffffffffffffffffffffffffff81165f526001865260405f20610c688482546130a0565b9055613381565b928391610c3c565b7f48f5c3ed000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610cd6612df2565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d757335f90815273ffffffffffffffffffffffffffffffffffffffff8216602052604090205c610d2c602435613233565b9081600f0b03610d4757610aa59133915f03600f0b90613279565b7fbda73abf000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610da736612f34565b610daf612f22565b9073ffffffffffffffffffffffffffffffffffffffff600254163303610c77576103e9610fff831610623e900062fff0008416101615610e7b57602060a07fe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9922092835f526006825260405f20610e258161364d565b805479ffffff00000000000000000000000000000000000000000000008360b81b16907fffffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffff1617905562ffffff60405191168152a2005b62ffffff827fa7abe2f7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b346103305760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610ee436612f34565b60a4359073ffffffffffffffffffffffffffffffffffffffff82168083036103305760c43567ffffffffffffffff811161033057610f26903690600401613000565b90610f2f6135e6565b6060840193845160020b617fff81136115125750845160020b600181126114e7575073ffffffffffffffffffffffffffffffffffffffff81511692602082019373ffffffffffffffffffffffffffffffffffffffff855116808210156114b05750506080820173ffffffffffffffffffffffffffffffffffffffff815116956040840196610fc362ffffff89511682613a8e565b156114855750610fd862ffffff885116613b4c565b91805173ffffffffffffffffffffffffffffffffffffffff8116908133036113c2575b505060a08520955f73ffffffffffffffffffffffffffffffffffffffff600254168061127e575b50875f52600660205260405f2090815473ffffffffffffffffffffffffffffffffffffffff166112565773ffffffffffffffffffffffffffffffffffffffff7fdd466e674ea557f56295e2d0218a125ea4b4f0f6f3307b95f85e6110838d64389860a09860209f98839662ffffff9685966110ba7cffffff00000000000000000000000000000000000000000000000000009d61460a565b9c8d9460d01b169079ffffff00000000000000000000000000000000000000000000008f76ffffff00000000000000000000000000000000000000008f9188901b16179160b81b16171790558851908a86831692833303611154575b5050505050505116995116995116995160020b91511690604051998a528a8a01526040890152606088015260020b95866080820152a4604051908152f35b61100016611163575b81611116565b61121a6112469261124b96604051966020947fa910f80f0000000000000000000000000000000000000000000000000000000089968701523360248701526111f8604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60e486015260020b61010485015261012061012485015261014484019161311f565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101845283612ee1565b613ffc565b508f8881808a61115d565b7f7983c051000000000000000000000000000000000000000000000000000000005f5260045ffd5b90505a907f000000000000000000000000000000000000000000000000000000000000000080921061139a576020915f918260405191858301927f553bfc370000000000000000000000000000000000000000000000000000000084526113338d602483019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60a4815261134260c482612ee1565b5193f15f519060203d14168061138c575b80611371575b1561136a5762ffffff165b8c611022565b505f611364565b506103e9610fff821610623e900062fff00083161016611359565b5062ffffff81168114611353565b7f1ee49702000000000000000000000000000000000000000000000000000000005f5260045ffd5b612000166113d1575b80610ffb565b61147e90604051907f3440d82000000000000000000000000000000000000000000000000000000000602083015233602483015261145c604483018973ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8460e48301526101006101048301526112468261121a61012482018a8d61311f565b508a6113cb565b7fe65af6a0000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b60449250604051917f6e6c983000000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b7fe9e90588000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fb70024f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b34610330576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761157636612f34565b60807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c36011261033057604051906115ad82612e8d565b60a4358060020b810361033057825260c4358060020b810361033057602083015260e43560408301526101043560608301526101243567ffffffffffffffff811161033057611600903690600401613000565b90927fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576116316135e6565b60a0832093845f52600660205260405f2060805261165060805161364d565b608084015173ffffffffffffffffffffffffffffffffffffffff811690813303611fa6575b5050815160020b92602083015160020b91611693604085015161385c565b93606087015160020b9760608201516040519960c08b018b811067ffffffffffffffff821117611f7957604052338b528860208c01528660408c015287600f0b60608c015260808b015260a08a01525f9185881215611f42577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276188812611f1657620d89e88613611eea576040519261172a84612e8d565b5f84525f60208501525f60408501525f606085015287600f0b611c13575b600460805101978960020b5f528860205260405f20988860020b5f5260205260405f206080515460a01c60020b8b81125f14611bbd575060028060018c0154600184015490039b015491015490039b5b60a073ffffffffffffffffffffffffffffffffffffffff825116910151906040519160268301528960068301528b600383015281525f603a600c83012091816040820152816020820152525f5260066080510160205260405f20976fffffffffffffffffffffffffffffffff8954169982600f0b155f14611b60578a15611b385761185d61185760409f9b61193c9c61194e9e5b600183019561184f6002611843848a5485036156b7565b950192835485036156b7565b965555613233565b91613233565b6fffffffffffffffffffffffffffffffff169060801b179a8b965f84600f0b12611aca575b5082600f0b611986575b5050506118b26118a38560801d8360801d0161385c565b9185600f0b90600f0b0161385c565b6fffffffffffffffffffffffffffffffff169060801b1791815160020b90602083015160020b8c8401516060850151918e5194855260208501528d84015260608301527ff208f4912782fd25c7f114ca3723a2d5dd6f3bcc3ac8db5af63baa85f711d5ec60803393a38873ffffffffffffffffffffffffffffffffffffffff608082015116613932565b8094919461195a575b50833391613729565b82519182526020820152f35b6119809073ffffffffffffffffffffffffffffffffffffffff6080840151169083613729565b85611945565b60805154929350909173ffffffffffffffffffffffffffffffffffffffff81169060a01c60020b828112156119ec575050906119e0926119d56119cb6119db94614166565b91600f0b92614166565b90614535565b61385c565b60801b5b8b808061188c565b92809193125f14611a9757611a2b91611a186119db6119db93611a1288600f0b91614166565b87614535565b93611a2686600f0b92614166565b6144d8565b6fffffffffffffffffffffffffffffffff169060801b17906fffffffffffffffffffffffffffffffff611a6a60036080510192600f0b8284541661457c565b167fffffffffffffffffffffffffffffffff000000000000000000000000000000008254161790556119e4565b906119db925092611aad6119cb611ab395614166565b906144d8565b6fffffffffffffffffffffffffffffffff166119e4565b808f9151611b0c575b0151611ae0575b8e611882565b611b078260805160049160020b5f52016020525f6002604082208281558260018201550155565b611ada565b611b338360805160049160020b5f52016020525f6002604082208281558260018201550155565b611ad3565b7faefeb924000000000000000000000000000000000000000000000000000000005f5260045ffd5b61185d61185760409f9b61193c9c61194e9e6fffffffffffffffffffffffffffffffff611b9089600f0b8361457c565b167fffffffffffffffffffffffffffffffff0000000000000000000000000000000084541617835561182c565b9099908913611be35760028060018c0154600184015490039b015491015490039b611798565b9860026001608051015460018c01549003600183015490039a81806080510154910154900391015490039b611798565b6004608051018960020b5f5280602052898960405f20611c6c81546fffffffffffffffffffffffffffffffff611c4f81831695600f0b8661457c565b16931594858515141595611eb6575b508d600f0b9060801d613e11565b60801b82179055602087015285528760020b5f5260205260405f208054906fffffffffffffffffffffffffffffffff8216611caa8b600f0b8261457c565b901592836fffffffffffffffffffffffffffffffff831615141593611e89575b8b600f0b9060801d600f0b03916f7fffffffffffffffffffffffffffffff83137fffffffffffffffffffffffffffffffff80000000000000000000000000000000841217611e5c57826fffffffffffffffffffffffffffffffff935060801b83831617905516606086015260408501525f88600f0b1215611d8f575b8351611d73575b60408401511561174857611d6e60808c015160020b8860056080510161411a565b611748565b611d8a60808c015160020b8a60056080510161411a565b611d4d565b60808b015160020b6fffffffffffffffffffffffffffffffff60018160208801511692807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276180590620d89e8050301810416809111611e30576fffffffffffffffffffffffffffffffff6060860151161115611d4657867fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b897fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6080515460a01c60020b8b13611cca57600160805101546001840155600260805101546002840155611cca565b6080515460a01c60020b1215611ecd575b8e611c5e565b600160805101546001840155600260805101546002840155611ec7565b857f1ad777f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fd5e2f7ab000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b60448887604051917fc4433ed500000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f604085015113808091612072575b156120075750506040517f259982e5000000000000000000000000000000000000000000000000000000006020820152611ffe916112468261121a8887898c33602487016137a2565b505b8580611675565b159081612064575b5061201b575b50612000565b6040517f21d0ee7000000000000000000000000000000000000000000000000000000000602082015261205d916112468261121a8887898c33602487016137a2565b5085612015565b61020091501615158761200f565b5061080082161515611fb5565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576120b6612df2565b73ffffffffffffffffffffffffffffffffffffffff6120d3612e15565b91165f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f52602052602060405f2054604051908152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761214e612df2565b602435908115158092036103305773ffffffffffffffffffffffffffffffffffffffff90335f52600360205260405f208282165f5260205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff851617905560405192835216907fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa26760203392a3602060405160018152f35b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761222636612f34565b61222e612f22565b906280000062ffffff604083015116148015906122e2575b6122ba5760a09061225683613765565b205f52600660205260405f209061226c8261364d565b81547fffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff1660d09190911b7cffffff000000000000000000000000000000000000000000000000000016179055005b7f30d21641000000000000000000000000000000000000000000000000000000005f5260045ffd5b5073ffffffffffffffffffffffffffffffffffffffff608082015116331415612246565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043567ffffffffffffffff811161033057612355903690600401613000565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c612569576123e1915f9160017fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d60405193849283927f91dd734600000000000000000000000000000000000000000000000000000000845260206004850152602484019161311f565b038183335af190811561255e575f916124b6575b507f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c61248e5760406020915f7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f835194859381855280519182918282880152018686015e5f85828601015201168101030190f35b7f5212cba1000000000000000000000000000000000000000000000000000000005f5260045ffd5b90503d805f833e6124c78183612ee1565b8101906020818303126103305780519067ffffffffffffffff8211610330570181601f820112156103305780519067ffffffffffffffff8211611f79576040519261253a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8601160185612ee1565b8284526020838301011161033057815f9260208093018386015e83010152816123f5565b6040513d5f823e3d90fd5b7f5090d6c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305773ffffffffffffffffffffffffffffffffffffffff6125b436612e38565b91929092335f52600560205260405f208282165f5260205260405f20845f526020528260405f205560405192835216907fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760203392a4602060405160018152f35b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612647612df2565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576107a2602091613504565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576024356004356040519160408360208152826020820152019060051b8301916001602060408501935b835481520191019084838210156109cc575060206001916126d1565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043573ffffffffffffffffffffffffffffffffffffffff81168091036103305761275f73ffffffffffffffffffffffffffffffffffffffff5f541633146130ba565b807fffffffffffffffffffffffff000000000000000000000000000000000000000060025416176002557fb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc5f80a2005b34610330576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576127e836612f34565b60c4359060a43560e43567ffffffffffffffff81116103305761280f903690600401613000565b9190937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576128416135e6565b60a0842094855f52600660205260405f209461285c8661364d565b60808101805173ffffffffffffffffffffffffffffffffffffffff8116908133036129f6575b50506fffffffffffffffffffffffffffffffff6003880154169788156129ce576020986128ae87613233565b5f036128b987613233565b5f036fffffffffffffffffffffffffffffffff169060801b1798876129ba575b866129a5575b50506128ec338985613729565b60405190868252858a8301527f29ef05caaff9404b7cb6d1c0e9bbae9eaa7ab2541feba1a9c4248594c08156cb60403393a3519273ffffffffffffffffffffffffffffffffffffffff84169384330361294a575b8888604051908152f35b601016612958575b80612940565b612999956112469361121a926040519788957fe1b4af69000000000000000000000000000000000000000000000000000000008d8801523360248801613693565b50828080808080612952565b600201908660801b04815401905589806128df565b60018101828960801b0481540190556128d9565b7fa74f97ab000000000000000000000000000000000000000000000000000000005f5260045ffd5b602016612a04575b80612882565b6040517fb6a8b0fa000000000000000000000000000000000000000000000000000000006020820152612a47916112468261121a8b898b8d8b3360248801613693565b50886129fe565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057600435545f5260205ff35b3461033057612a9636612e38565b907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ed73ffffffffffffffffffffffffffffffffffffffff805f941695612b15612b0887613233565b8603600f0b339089613279565b16938484526004602052604084208685526020526040842061025f8282546130ad565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d75760206107a233613504565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612bca612df2565b612bd2612e15565b604435907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d757610aa592612c1a612c0d84613233565b5f03600f0b339083613279565b613381565b346103305773ffffffffffffffffffffffffffffffffffffffff612c4236612e38565b91929092335f52600460205260405f20845f5260205260405f20612c678482546130a0565b90551690815f52600460205260405f20835f5260205260405f20612c8c8282546130ad565b9055604080513380825260208201939093527f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288599181908101610279565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361033057807f01ffc9a70000000000000000000000000000000000000000000000000000000060209214908115612d5e575b506040519015158152f35b7f0f632fb30000000000000000000000000000000000000000000000000000000091501482612d53565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760209073ffffffffffffffffffffffffffffffffffffffff612dd7612df2565b165f526004825260405f206024355f52825260405f20548152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126103305760043573ffffffffffffffffffffffffffffffffffffffff8116810361033057906024359060443590565b6080810190811067ffffffffffffffff821117611f7957604052565b6060810190811067ffffffffffffffff821117611f7957604052565b60a0810190811067ffffffffffffffff821117611f7957604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611f7957604052565b60a4359062ffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60a09101126103305760405190612f6b82612ec5565b8160043573ffffffffffffffffffffffffffffffffffffffff8116810361033057815260243573ffffffffffffffffffffffffffffffffffffffff8116810361033057602082015260443562ffffff811681036103305760408201526064358060020b81036103305760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036103305760800152565b9181601f840112156103305782359167ffffffffffffffff8311610330576020838186019501011161033057565b9060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126103305760043567ffffffffffffffff811161033057826023820112156103305780600401359267ffffffffffffffff84116103305760248460051b83010111610330576024019190565b91908203918211611e5c57565b91908201809211611e5c57565b156130c157565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152fd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b73ffffffffffffffffffffffffffffffffffffffff7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95c1661320b5773ffffffffffffffffffffffffffffffffffffffff8116908115613207576131c090613b69565b907f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95d7f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955d565b5050565b7f996caf65000000000000000000000000000000000000000000000000000000005f5260045ffd5b6f8000000000000000000000000000000081101561325157600f0b90565b7f93dafdf1000000000000000000000000000000000000000000000000000000005f5260045ffd5b9190600f0b91821561337c576132af919073ffffffffffffffffffffffffffffffffffffffff8092165f521660205260405f2090565b6132bb815c9283613c00565b80915d61332c57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d5b565b1561333357565b60017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d565b505050565b90919073ffffffffffffffffffffffffffffffffffffffff8116908161341f5750505f80808093855af1156133b35750565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d604051937f8549db59000000000000000000000000000000000000000000000000000000008552600485015260406024850152806044850152805f606486013e011660640190fd5b60205f60448194968260409573ffffffffffffffffffffffffffffffffffffffff988751998a947fa9059cbb00000000000000000000000000000000000000000000000000000000865216600485015260248401525af13d15601f3d116001855114161716928281528260208201520152156134985750565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d604051937fb12c5f9c000000000000000000000000000000000000000000000000000000008552600485015260406024850152806044850152805f606486013e011660640190fd5b7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95c919073ffffffffffffffffffffffffffffffffffffffff83166135595761332a9034935b61355385613233565b90613279565b346135be5761332a906135957f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955c61359086613b69565b6130a0565b935f7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95d61354a565b7fb0ec849e000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361362557565b7f0d89438e000000000000000000000000000000000000000000000000000000005f5260045ffd5b5473ffffffffffffffffffffffffffffffffffffffff161561366b57565b7f486aa307000000000000000000000000000000000000000000000000000000005f5260045ffd5b919261370e6101209473ffffffffffffffffffffffffffffffffffffffff613726999794168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60c083015260e082015281610100820152019161311f565b90565b9073ffffffffffffffffffffffffffffffffffffffff602061332a949361375885848351168660801d90613279565b01511690600f0b90613279565b62ffffff16620f424081116137775750565b7f14002113000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b90613726959361381f6101609473ffffffffffffffffffffffffffffffffffffffff61384e94168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08501526020820151900b60e0840152604081015161010084015260600151610120830152565b81610140820152019161311f565b9081600f0b91820361325157565b92613918906138e961372699979473ffffffffffffffffffffffffffffffffffffffff6101a09895168752602087019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08701526020820151900b60e0860152604081015161010086015260600151610120850152565b61014083015261016082015281610180820152019161311f565b939590919296945f9673ffffffffffffffffffffffffffffffffffffffff86163314613a8357885f6040870151135f14613a12576104008716613979575b50505050505050565b613a0597999850926139fe969594926139c6926139f2956040519788967f9f063efc000000000000000000000000000000000000000000000000000000006020890152336024890161386a565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282612ee1565b600282161515916145ad565b80926145cd565b915f808080808080613970565b9594939291906101008616613a2a5750505050505050565b613a05979950869850916139c691613a7794936139fe986040519788967f6c2bbe7e000000000000000000000000000000000000000000000000000000006020890152336024890161386a565b600182161515916145ad565b505f96505050505050565b608081161580613b40575b613b1657604081161580613b34575b613b165761040081161580613b28575b613b165761010081161580613b1c575b613b165773ffffffffffffffffffffffffffffffffffffffff8116613af6575062ffffff1662800000141590565b613fff161590811591613b07575090565b62800000915062ffffff161490565b50505f90565b50600181161515613ac8565b50600281161515613ab8565b50600481161515613aa8565b50600881161515613a99565b6280000062ffffff821614613b645761372681613765565b505f90565b73ffffffffffffffffffffffffffffffffffffffff1680613b8957504790565b6020602491604051928380927f70a082310000000000000000000000000000000000000000000000000000000082523060048301525afa90811561255e575f91613bd1575090565b90506020813d602011613bf8575b81613bec60209383612ee1565b81010312610330575190565b3d9150613bdf565b9190915f8382019384129112908015821691151617611e5c57565b6020830151955f9586959194913373ffffffffffffffffffffffffffffffffffffffff851614613e045760808416613c55575b5050505050565b613d3d926139c6613d3792613d23946040519586947f575e24b4000000000000000000000000000000000000000000000000000000006020870152336024870152613ced604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051151560e487015260208101516101048701526040015173ffffffffffffffffffffffffffffffffffffffff16610124860152565b61014061014485015261016484019161311f565b82613ffc565b916060835103613ddc576040015162ffffff166280000014613dd0575b600816613d6b575b80808080613c4e565b604001519250608083901d600f0b8015613d6257613d8c905f861295613c00565b9315613dc8575f84135b613da0575f613d62565b7ffa0b71d6000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f8412613d96565b60608201519350613d5a565b7f1e048e1d000000000000000000000000000000000000000000000000000000005f5260045ffd5b505f965086955050505050565b90600f0b90600f0b01907fffffffffffffffffffffffffffffffff8000000000000000000000000000000082126f7fffffffffffffffffffffffffffffff831317611e5c57565b9196959394929473ffffffffffffffffffffffffffffffffffffffff83163314613fef578460801d94600f0b938860408516613f17575b50505050505f9481600f0b15801590613f0b575b613eaf575b5050509190565b613ee69395505f60208201511290511515145f14613eee576fffffffffffffffffffffffffffffffff169060801b175b80936145cd565b5f8080613ea8565b906fffffffffffffffffffffffffffffffff169060801b17613edf565b5082600f0b1515613ea3565b613fd3613fdf946139c66119db95613fe5999895613fb8613ced966040519788967fb47b2fb1000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8c61014485015261016061016485015261018484019161311f565b600482161515916145ad565b90613e11565b5f80808088613e8f565b5050505050909150905f90565b9190915f80602085519501948582855af1156140985750604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f3d011683016040523d83523d9060208401915f833e6020845110918215614064575b5050613ddc57565b5190517fffffffff000000000000000000000000000000000000000000000000000000009182169116141590505f8061405c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d73ffffffffffffffffffffffffffffffffffffffff604051947f319d54c300000000000000000000000000000000000000000000000000000000865216600485015260406024850152806044850152805f606486013e011660640190fd5b919060020b9060020b908181076141485705908160081d5f52602052600160ff60405f2092161b8154189055565b601c906044926040519163d4d8f3e683526020830152604082015201fd5b60020b908160ff1d82810118620d89e881116144ac5763ffffffff9192600182167001fffcb933bd6fad37aa2d162d1a59400102700100000000000000000000000000000000189160028116614490575b60048116614474575b60088116614458575b6010811661443c575b60208116614420575b60408116614404575b608081166143e8575b61010081166143cc575b61020081166143b0575b6104008116614394575b6108008116614378575b611000811661435c575b6120008116614340575b6140008116614324575b6180008116614308575b6201000081166142ec575b6202000081166142d1575b6204000081166142b6575b620800001661429d575b5f12614276575b0160201c90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0461426f565b6b048a170391f7dc42444e8fa290910260801c90614268565b6d2216e584f5fa1ea926041bedfe9890920260801c9161425e565b916e5d6af8dedb81196699c329225ee6040260801c91614253565b916f09aa508b5b7a84e1c677de54f3e99bc90260801c91614248565b916f31be135f97d08fd981231505542fcfa60260801c9161423d565b916f70d869a156d2a1b890bb3df62baf32f70260801c91614233565b916fa9f746462d870fdf8a65dc1f90e061e50260801c91614229565b916fd097f3bdfd2022b8845ad8f792aa58250260801c9161421f565b916fe7159475a2c29b7443b29c7fa6e889d90260801c91614215565b916ff3392b0822b70005940c7a398e4b70f30260801c9161420b565b916ff987a7253ac413176f2b074cf7815e540260801c91614201565b916ffcbe86c7900a88aedcffc83b479aa3a40260801c916141f7565b916ffe5dee046a99a2a811c461f1969c30530260801c916141ed565b916fff2ea16466c96a3843ec78b326b528610260801c916141e4565b916fff973b41fa98c081472e6896dfb254c00260801c916141db565b916fffcb9843d60f6159c9db58835c9266440260801c916141d2565b916fffe5caca7e10e4e61c3624eaa0941cd00260801c916141c9565b916ffff2e50f5f656932ef12357cf3c7fdcc0260801c916141c0565b916ffff97272373d413259a46990580e213a0260801c916141b7565b827f8b86327a000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b905f83600f0b125f1461450d57614503925f036fffffffffffffffffffffffffffffffff16916159f1565b5f81126132515790565b614529926fffffffffffffffffffffffffffffffff1691615996565b5f8112613251575f0390565b905f83600f0b125f1461456057614503925f036fffffffffffffffffffffffffffffffff1691615ae8565b614529926fffffffffffffffffffffffffffffffff1691615a31565b906fffffffffffffffffffffffffffffffff90600f0b911601908160801c6145a057565b6393dafdf15f526004601cfd5b906145b791613ffc565b9015613b64576040815103613ddc576040015190565b6145f0906145e28360801d8260801d0361385c565b92600f0b90600f0b0361385c565b6fffffffffffffffffffffffffffffffff169060801b1790565b73fffd8963efd1fc6a506488495d951d516396168273ffffffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffefffd895d830116116148ee5777ffffffffffffffffffffffffffffffffffffffff000000008160201b168060ff61468783615b8f565b1691608083106148e257507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8182011c5b800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c80029081607f1c8260ff1c1c80029283607f1c8460ff1c1c80029485607f1c8660ff1c1c80029687607f1c8860ff1c1c80029889607f1c8a60ff1c1c80029a8b607f1c8c60ff1c1c80029c8d80607f1c9060ff1c1c800260cd1c6604000000000000169d60cc1c6608000000000000169c60cb1c6610000000000000169b60ca1c6620000000000000169a60c91c6640000000000000169960c81c6680000000000000169860c71c670100000000000000169760c61c670200000000000000169660c51c670400000000000000169560c41c670800000000000000169460c31c671000000000000000169360c21c672000000000000000169260c11c674000000000000000169160c01c67800000000000000016907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800160401b1717171717171717171717171717693627a301d71055774c85027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc556810160801d60020b906fdb2df09e81959a81455e260799a0632f0160801d60020b918282145f1461489f5750905090565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff6148d384614166565b16116148dd575090565b905090565b905081607f031b6146b7565b73ffffffffffffffffffffffffffffffffffffffff907f61487524000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b811561493a570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b90915f926040519161497883612ea9565b5f83525f60208401525f60408401528294845493602084015115936fffffffffffffffffffffffffffffffff6003880154169085155f146156a957610fff8760b81c16925b6040820151915f9388155f1461569f5760018b01545b978a73ffffffffffffffffffffffffffffffffffffffff1684528a60a01c60020b6020850152816040850152608083015162400000811615155f146156905762bfffff16614a2081613765565b61ffff881661566d57915b825f60408601511295620f424062ffffff83161015615640575b6040860151156156285750508a6155b4576060840173ffffffffffffffffffffffffffffffffffffffff8151168d73ffffffffffffffffffffffffffffffffffffffff1681101561556757505173ffffffffffffffffffffffffffffffffffffffff166401000276a381111561553c57505b6040519b8c67ffffffffffffffff60e0828181011092011117611f7957958e5f60c08f60e081016040528281528260208201528260408201528260608201528260808201528260a082015201525b8115908115615501575b506153c8578e8d8f8e9073ffffffffffffffffffffffffffffffffffffffff8451168352602084015160020b91895160020b92835f8183071291050390155f1461526b579182600560ff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189516938260020b60081d60010b5f520160205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8460ff031c9054169283151593845f146152595790614bd260ff92615b8f565b90031660020b900360020b0260020b5b905b1515604084015260020b806020840152131561522d575b620d89e8602082015160020b121561521e575b8d600173ffffffffffffffffffffffffffffffffffffffff614c36602085015160020b614166565b1680606085015273ffffffffffffffffffffffffffffffffffffffff8551169273ffffffffffffffffffffffffffffffffffffffff60608c015116928391151681831018911802186fffffffffffffffffffffffffffffffff60408501511662ffffff89169273ffffffffffffffffffffffffffffffffffffffff8316811015915f88125f146150795784620f424003614cd2818a5f03615739565b94841561506857614ce4838583615a31565b955b868110614fad57509173ffffffffffffffffffffffffffffffffffffffff97939160809593978891620f424082145f14614f9e575050865b935b15614f905791614d2f926159f1565b905b60c083015260a0820152015216905285614f585760a08d0151905f8212613251570395614d688d60c06080820151910151906130ad565b5f8112613251578803978813600116611e5c578e8d8f8e5b61ffff8d16614f2b575b6fffffffffffffffffffffffffffffffff60408501511680614f18575b508e73ffffffffffffffffffffffffffffffffffffffff85511673ffffffffffffffffffffffffffffffffffffffff60608601511681145f14614ed757506040840151614e47575b505050508d8d155f14614e3b5760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91015160020b0160020b5b60020b60208201525b969096614b05565b6020015160020b614e2a565b6fffffffffffffffffffffffffffffffff936004614eb09484155f14614ec95760206002820154935b015160020b60020b5f520160205260405f2091600183019081549003905560028201908154900390555460801d9015614ebf575b8260408501511661457c565b1660408201528d8f8e8e614def565b5f03600f0b614ea4565b602060018201549493614e70565b9391505073ffffffffffffffffffffffffffffffffffffffff915051168103614f01575b50614e33565b614f0a9061460a565b60020b60208201525f614efb565b60c084015160801b04909e019d5f614da7565b9c620f42408d61ffff608086015191169060c0860151010204908160c08501510360c0850152019c614d8a565b60808d015160c08e015101905f821261325157019560a08d0151975f8912613251578f908f8f918f9b614f8a91613c00565b9a614d80565b614f9992615ae8565b614d2f565b614fa89189615c1c565b614d1e565b96505050919250938392821586151761505b5773ffffffffffffffffffffffffffffffffffffffff956080938215614ff657614fea878284615cbb565b80978b015f0393614d20565b8787116150345761502f61502a6150226fffffffffffffffffffffffffffffffff84168a60601b614930565b8a85166130ad565b615d4f565b614fea565b61502f61502a6150566fffffffffffffffffffffffffffffffff84168a61583e565b615022565b634f2461b85f526004601cfd5b615073838286615996565b95614ce6565b9294919392841561520d5761508f8183886159f1565b955b8689106150ea576080939273ffffffffffffffffffffffffffffffffffffffff97926150d79280985b156150dc57916150c992615a31565b809580620f42400391615c1c565b614d31565b6150e592615996565b6150c9565b5094509086851583151761505b5784156151e15773ffffffffffffffffffffffffffffffffffffffff881161518e578760601b6fffffffffffffffffffffffffffffffff871680820615159104015b73ffffffffffffffffffffffffffffffffffffffff841693818511156151815773ffffffffffffffffffffffffffffffffffffffff97886150d79360809703165b80986150ba565b634323a5555f526004601cfd5b6fffffffffffffffffffffffffffffffff86166151b9816c010000000000000000000000008b6158f7565b90801561493a576c010000000000000000000000008a09156151395760010180615139575f80fd5b6150d783876152088b73ffffffffffffffffffffffffffffffffffffffff9a608098615c45565b61517a565b615218818784615ae8565b95615091565b6020620d89e89101528d614c0e565b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189101528d614bfb565b5060020b900360020b0260020b614be2565b600160059101918260020b60081d60010b5f520160205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600160ff84161b011990541691821591821592835f14615388576103305760ff847ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618955f03166101e07f804040554300526644320000502061067405302602000010750620017611707760fc7fb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff840260f81c161b60f71c167e1f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405601f85851693831c63d76453e004161a17031660020b9060020b0160020b0260020b5b90614be4565b507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618935060ff81811681031660020b9060020b0160020b0260020b615382565b9750919a509b98939a91969a9792949760208a015160a01b76ffffff0000000000000000000000000000000000000000167fffffffffffffffffff000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8c51169216171782556fffffffffffffffffffffffffffffffff60408a0151168091036154bc575b5082156154b357600201555b151461549b576040615478615481939461385c565b9301510361385c565b6fffffffffffffffffffffffffffffffff169060801b1793565b6154ad9060406154819301510361385c565b9161385c565b60010155615463565b6fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff000000000000000000000000000000006003830154161760038201555f615457565b73ffffffffffffffffffffffffffffffffffffffff9150511673ffffffffffffffffffffffffffffffffffffffff606087015116148f614b0f565b7f9e4d7cc7000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b8d604491604051917f7c9c6e8f00000000000000000000000000000000000000000000000000000000835273ffffffffffffffffffffffffffffffffffffffff1660048301526024820152fd5b6060840173ffffffffffffffffffffffffffffffffffffffff8151168d73ffffffffffffffffffffffffffffffffffffffff1681111561556757505173ffffffffffffffffffffffffffffffffffffffff1673fffd8963efd1fc6a506488495d951d5263988d2681101561553c5750614ab7565b9c509c50509b505050505050505050505f925f929190565b86614a45577f96206246000000000000000000000000000000000000000000000000000000005f5260045ffd5b62ffffff610fff89169116808202620f4240808206151591040191010391614a2b565b508a60d01c62ffffff16614a20565b60028b01546149d3565b610fff8760c41c16926149bd565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393847001000000000000000000000000000000001115610330571461573057700100000000000000000000000000000000910990828211900360801b910360801c1790565b50505060801c90565b818102907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83820990828083109203918083039283620f4240111561033057146157b8577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c2613993620f4240910990828211900360fa1b910360061c170290565b5050620f424091500490565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393846c0100000000000000000000000011156103305714615835576c01000000000000000000000000910990828211900360a01b910360601c1790565b50505060601c90565b908160601b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c0100000000000000000000000084099282808510940393808503948584111561033057146158f0576c0100000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b5091500490565b91818302917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81850993838086109503948086039586851115610330571461598e579082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b505091500490565b6fffffffffffffffffffffffffffffffff6c010000000000000000000000009173ffffffffffffffffffffffffffffffffffffffff80600195169116038060ff1d908101189316926159e881856157c4565b93091515160190565b6fffffffffffffffffffffffffffffffff9073ffffffffffffffffffffffffffffffffffffffff806137269594169116038060ff1d9081011891166157c4565b9073ffffffffffffffffffffffffffffffffffffffff811673ffffffffffffffffffffffffffffffffffffffff831611615ae2575b73ffffffffffffffffffffffffffffffffffffffff8216928315615ad6577bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff615aca948185169403169160601b16615c1c565b90808206151591040190565b62bfc9215f526004601cfd5b90615a66565b73ffffffffffffffffffffffffffffffffffffffff821673ffffffffffffffffffffffffffffffffffffffff821611615b89575b73ffffffffffffffffffffffffffffffffffffffff8116918215615ad657613726937bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff615b84948185169403169160601b166158f7565b614930565b90615b1c565b8015610330577f07060605060205000602030205040001060502050303040105050304000000006f8421084210842108cc6318c6db6d54be826fffffffffffffffffffffffffffffffff1060071b83811c67ffffffffffffffff1060061b1783811c63ffffffff1060051b1783811c61ffff1060041b1783811c60ff1060031b1792831c1c601f161a1790565b929190615c2a8282866158f7565b93821561493a5709615c3857565b9060010190811561033057565b91908115615cb6577bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff9160601b169216918282029183838311918404141615615ca9576137269261502a92820391615c1c565b63f5c787f15f526004601cfd5b505090565b90918015615d495773ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffffffffffffffffffff000000000000000000000000819460601b16921680820281615d0b8483614930565b14615d31575b5090615d20615d259284614930565b6130ad565b80820615159104011690565b8301838110615d11579150615d4592615c1c565b1690565b50905090565b9073ffffffffffffffffffffffffffffffffffffffff82169182036132515756fea164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC04`\x9DW`\x1Fa^38\x81\x90\x03\x91\x82\x01`\x1F\x19\x16\x83\x01\x91`\x01`\x01`@\x1B\x03\x83\x11\x84\x84\x10\x17`\xA1W\x80\x84\x92` \x94`@R\x839\x81\x01\x03\x12`\x9DWQ_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x82U`@Q\x92\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x81\x80\xA3`\x80R0`\xA0Ra]}\x90\x81a\0\xB6\x829`\x80Q\x81a\x12\x84\x01R`\xA0Q\x81a5\xFD\x01R\xF3[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD\xFE`\xA0\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xFD\xD5\x8E\x14a-\x88WP\x80c\x01\xFF\xC9\xA7\x14a,\xC9W\x80c\t[\xCD\xB6\x14a,\x1FW\x80c\x0B\r\x9C\t\x14a+\x93W\x80c\x11\xDA`\xB4\x14a+8W\x80c\x15n)\xF6\x14a*\x88W\x80c\x1E.\xAE\xAF\x14a*NW\x80c#Bf\xD7\x14a'\xAFW\x80c-w\x13\x89\x14a&\xEDW\x80c5\xFDc\x1A\x14a&yW\x80c=\xD4Z\xDB\x14a&\x15W\x80cBj\x84\x93\x14a%\x91W\x80cH\xC8\x94\x91\x14a#\x06W\x80cRu\x96Q\x14a!\xEEW\x80cU\x8Ar\x97\x14a!\x17W\x80cY\x8A\xF9\xE7\x14a \x7FW\x80cZk\xCF\xDA\x14a\x15=W\x80ci\\[\xF5\x14a\x0E\xACW\x80c~\x87\xCE}\x14a\roW\x80c\x80\xF0\xB4L\x14a\x0C\x9FW\x80c\x81a\xB8t\x14a\x0B\xA7W\x80c\x8D\xA5\xCB[\x14a\x0BWW\x80c\x97\xE8\xCDN\x14a\n\xF4W\x80c\x9B\xF6d_\x14a\n\xA7W\x80c\xA5\x84\x11\x94\x14a\nfW\x80c\xB66<\xF2\x14a\t\xD5W\x80c\xDB\xD05\xFF\x14a\t\x7FW\x80c\xF0-\xE3\xB2\x14a\t.W\x80c\xF15\xBA\xAA\x14a\x08\xF4W\x80c\xF2\xFD\xE3\x8B\x14a\x08HW\x80c\xF3\xCD\x91L\x14a\x04\xFFW\x80c\xF5)\x8A\xCA\x14a\x034Wc\xFE\x99\x04\x9A\x14a\x01\x86W_\x80\xFD[4a\x030W`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x01\xBDa-\xF2V[a\x01\xC5a.\x15V[\x90`D5\x91\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x02ys\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`d5\x95\x16\x93\x843\x14\x15\x80a\x03\rW[a\x02\x87W[\x84_R`\x04` R`@_ \x87_R` R`@_ a\x02:\x87\x82Ta0\xA0V[\x90U\x16\x93\x84_R`\x04` R`@_ \x86_R` R`@_ a\x02_\x82\x82Ta0\xADV[\x90U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x90\x91\x82\x91\x82\x01\x90V[\x03\x90\xA4` `@Q`\x01\x81R\xF3[\x84_R`\x05` R`@_ \x823\x16_R` R`@_ \x87_R` R`@_ T\x86\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x02\xDAW[PPa\x02\x19V[a\x02\xE3\x91a0\xA0V[\x85_R`\x05` R`@_ \x833\x16_R` R`@_ \x88_R` R`@_ U_\x86a\x02\xD3V[P\x84_R`\x03` R`@_ \x823\x16_R` R`\xFF`@_ T\x16\x15a\x02\x14V[_\x80\xFD[4a\x030Wa\x03B6a.8V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEDs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80_\x95\x16\x95a\x03\xBBa\x03\xB3\x86a23V[3\x90\x89a2yV[\x16\x923\x84\x14\x15\x80a\x04\xA0W[a\x03\xF2W[\x83\x85R`\x04` R`@\x85 \x86\x86R` R`@\x85 a\x02_\x82\x82Ta0\xA0V[\x03\x90\xA4\0[\x83\x85R`\x05` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`@\x85 \x86\x86R` R`@\x85 T\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x04YW[PPa\x03\xCCV[a\x04b\x91a0\xA0V[\x84\x86R`\x05` R`@\x86 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x87R` R`@\x86 \x87\x87R` R`@\x86 U\x86\x81a\x04RV[P\x83\x85R`\x03` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`\xFF`@\x86 T\x16\x15a\x03\xC7V[\x7FT\xE3\xCA\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Wa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0586a/4V[``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x05o\x82a.\xA9V[`\xA45\x80\x15\x15\x81\x03a\x030W\x82R` \x82\x01\x90`\xC45\x82R`\xE45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`@\x84\x01\x91\x82Ra\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x05\xD0\x906\x90`\x04\x01a0\0V[\x92\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x06\x02a5\xE6V[Q\x15a\x08 W`\xA0\x82 \x92\x83_R`\x06` R`@_ \x90a\x06#\x82a6MV[`\x80\x84\x01\x95\x84\x82\x82\x8A\x8AQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93a\x06N\x94a<\x1BV[\x90\x94\x91\x95``\x88\x01Q`\x02\x0B\x96\x8BQ\x15\x15\x91Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91`@Q\x98a\x06\x85\x8Aa.\xC5V[\x89R` \x89\x01R`@\x88\x01R``\x87\x01Rb\xFF\xFF\xFF\x16`\x80\x86\x01R\x88Q\x15\x15_\x14\x98b\xFF\xFF\xFFa\x07\xA2\x98a\x06\xDBa\x07\x8F\x98` \x9Da\x08\0Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8BQ\x16\x95aIgV[\x94\x92\x96\x82\x91\x92a\x07\xD3W[PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84Q\x16\x93\x8Eo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x83\x01Q\x16\x91\x01Q`\x02\x0B\x90`@Q\x95\x88`\x80\x1D`\x0F\x0B\x87R\x88`\x0F\x0B` \x88\x01R`@\x87\x01R``\x86\x01R`\x80\x85\x01R\x16`\xA0\x83\x01R\x7F@\xE9\xCE\xCB\x9F_\x1F\x1C[\x9C\x97\xDE\xC2\x91{~\xE9.W\xBAUcp\x8D\xAC\xA9M\xD8J\xD7\x11/`\xC03\x93\xA3\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AQ\x16a>XV[\x80\x94\x91\x94a\x07\xAAW[PP\x823\x91a7)V[`@Q\x90\x81R\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xCC\x92Q\x16\x90\x83a7)V[\x84\x80a\x07\x98V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R`\x01\x8FR`@_ \x90\x81T\x01\x90U\x8E\x80a\x06\xE6V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8E\x8C\x01Q\x16\x95aIgV[\x7F\xBE\x8B\x85\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x08\xA0a-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x91a\x08\xC5\x82\x84\x163\x14a0\xBAV[\x16\x91\x82\x91\x16\x17_U3\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\\_R` _\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16`@Q\x90\x81R\xF3[4a\x030Wa\t\x8D6a0.V[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` \x80\x91a\t\xB0V[`@\x81\x86\x03\x01\x90\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\n\x0Ca-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n)a.\x15V[\x91\x16_R`\x03` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\n\xA5a\n\xA0a-\xF2V[a1]V[\0[4a\x030Wa\n\xB56a0.V[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835\\\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` \x80\x91a\n\xD8V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B@a-\xF2V[\x16_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0B\xDEa-\xF2V[a\x0B\xE6a.\x15V[\x90`D5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0CwW` \x92a\x07\xA2\x91\x80a\x0CoWPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x84R`@_ T\x92\x83\x91[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x86R`@_ a\x0Ch\x84\x82Ta0\xA0V[\x90Ua3\x81V[\x92\x83\x91a\x0C<V[\x7FH\xF5\xC3\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\xD6a-\xF2V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W3_\x90\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16` R`@\x90 \\a\r,`$5a23V[\x90\x81`\x0F\x0B\x03a\rGWa\n\xA5\x913\x91_\x03`\x0F\x0B\x90a2yV[\x7F\xBD\xA7:\xBF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\r\xA76a/4V[a\r\xAFa/\"V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0CwWa\x03\xE9a\x0F\xFF\x83\x16\x10b>\x90\0b\xFF\xF0\0\x84\x16\x10\x16\x15a\x0E{W` `\xA0\x7F\xE9\xC4%\x93\xE7\x1F\x84@;\x845,\xD1h\xD6\x93\xE2\xC9\xFC\xD1\xFD\xBC\xC3\xFE\xB2\x1D\x92\xB4>f\x96\xF9\x92 \x92\x83_R`\x06\x82R`@_ a\x0E%\x81a6MV[\x80Ty\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`\xB8\x1B\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ub\xFF\xFF\xFF`@Q\x91\x16\x81R\xA2\0[b\xFF\xFF\xFF\x82\x7F\xA7\xAB\xE2\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[4a\x030W`\xE0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0E\xE46a/4V[`\xA45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x83\x03a\x030W`\xC45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x0F&\x906\x90`\x04\x01a0\0V[\x90a\x0F/a5\xE6V[``\x84\x01\x93\x84Q`\x02\x0Ba\x7F\xFF\x81\x13a\x15\x12WP\x84Q`\x02\x0B`\x01\x81\x12a\x14\xE7WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x92` \x82\x01\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x80\x82\x10\x15a\x14\xB0WPP`\x80\x82\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x95`@\x84\x01\x96a\x0F\xC3b\xFF\xFF\xFF\x89Q\x16\x82a:\x8EV[\x15a\x14\x85WPa\x0F\xD8b\xFF\xFF\xFF\x88Q\x16a;LV[\x91\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x13\xC2W[PP`\xA0\x85 \x95_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16\x80a\x12~W[P\x87_R`\x06` R`@_ \x90\x81Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12VWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xDDFngN\xA5W\xF5b\x95\xE2\xD0!\x8A\x12^\xA4\xB4\xF0\xF6\xF30{\x95\xF8^a\x10\x83\x8Dd8\x98`\xA0\x98` \x9F\x98\x83\x96b\xFF\xFF\xFF\x96\x85\x96a\x10\xBA|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9DaF\nV[\x9C\x8D\x94`\xD0\x1B\x16\x90y\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Fv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8F\x91\x88\x90\x1B\x16\x17\x91`\xB8\x1B\x16\x17\x17\x90U\x88Q\x90\x8A\x86\x83\x16\x92\x833\x03a\x11TW[PPPPPPQ\x16\x99Q\x16\x99Q\x16\x99Q`\x02\x0B\x91Q\x16\x90`@Q\x99\x8AR\x8A\x8A\x01R`@\x89\x01R``\x88\x01R`\x02\x0B\x95\x86`\x80\x82\x01R\xA4`@Q\x90\x81R\xF3[a\x10\0\x16a\x11cW[\x81a\x11\x16V[a\x12\x1Aa\x12F\x92a\x12K\x96`@Q\x96` \x94\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\x96\x87\x01R3`$\x87\x01Ra\x11\xF8`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xE4\x86\x01R`\x02\x0Ba\x01\x04\x85\x01Ra\x01 a\x01$\x85\x01Ra\x01D\x84\x01\x91a1\x1FV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x84R\x83a.\xE1V[a?\xFCV[P\x8F\x88\x81\x80\x8Aa\x11]V[\x7Fy\x83\xC0Q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90PZ\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x92\x10a\x13\x9AW` \x91_\x91\x82`@Q\x91\x85\x83\x01\x92\x7FU;\xFC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84Ra\x133\x8D`$\x83\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xA4\x81Ra\x13B`\xC4\x82a.\xE1V[Q\x93\xF1_Q\x90` =\x14\x16\x80a\x13\x8CW[\x80a\x13qW[\x15a\x13jWb\xFF\xFF\xFF\x16[\x8Ca\x10\"V[P_a\x13dV[Pa\x03\xE9a\x0F\xFF\x82\x16\x10b>\x90\0b\xFF\xF0\0\x83\x16\x10\x16a\x13YV[Pb\xFF\xFF\xFF\x81\x16\x81\x14a\x13SV[\x7F\x1E\xE4\x97\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a \0\x16a\x13\xD1W[\x80a\x0F\xFBV[a\x14~\x90`@Q\x90\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01R3`$\x83\x01Ra\x14\\`D\x83\x01\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x84`\xE4\x83\x01Ra\x01\0a\x01\x04\x83\x01Ra\x12F\x82a\x12\x1Aa\x01$\x82\x01\x8A\x8Da1\x1FV[P\x8Aa\x13\xCBV[\x7F\xE6Z\xF6\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[`D\x92P`@Q\x91\x7Fnl\x980\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x04\x83\x01R`$\x82\x01R\xFD[\x7F\xE9\xE9\x05\x88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xB7\0$\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[4a\x030Wa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x15v6a/4V[`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x15\xAD\x82a.\x8DV[`\xA45\x80`\x02\x0B\x81\x03a\x030W\x82R`\xC45\x80`\x02\x0B\x81\x03a\x030W` \x83\x01R`\xE45`@\x83\x01Ra\x01\x045``\x83\x01Ra\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x16\0\x906\x90`\x04\x01a0\0V[\x90\x92\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x161a5\xE6V[`\xA0\x83 \x93\x84_R`\x06` R`@_ `\x80Ra\x16P`\x80Qa6MV[`\x80\x84\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x1F\xA6W[PP\x81Q`\x02\x0B\x92` \x83\x01Q`\x02\x0B\x91a\x16\x93`@\x85\x01Qa8\\V[\x93``\x87\x01Q`\x02\x0B\x97``\x82\x01Q`@Q\x99`\xC0\x8B\x01\x8B\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@R3\x8BR\x88` \x8C\x01R\x86`@\x8C\x01R\x87`\x0F\x0B``\x8C\x01R`\x80\x8B\x01R`\xA0\x8A\x01R_\x91\x85\x88\x12\x15a\x1FBW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x88\x12a\x1F\x16Wb\r\x89\xE8\x86\x13a\x1E\xEAW`@Q\x92a\x17*\x84a.\x8DV[_\x84R_` \x85\x01R_`@\x85\x01R_``\x85\x01R\x87`\x0F\x0Ba\x1C\x13W[`\x04`\x80Q\x01\x97\x89`\x02\x0B_R\x88` R`@_ \x98\x88`\x02\x0B_R` R`@_ `\x80QT`\xA0\x1C`\x02\x0B\x8B\x81\x12_\x14a\x1B\xBDWP`\x02\x80`\x01\x8C\x01T`\x01\x84\x01T\x90\x03\x9B\x01T\x91\x01T\x90\x03\x9B[`\xA0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82Q\x16\x91\x01Q\x90`@Q\x91`&\x83\x01R\x89`\x06\x83\x01R\x8B`\x03\x83\x01R\x81R_`:`\x0C\x83\x01 \x91\x81`@\x82\x01R\x81` \x82\x01RR_R`\x06`\x80Q\x01` R`@_ \x97o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89T\x16\x99\x82`\x0F\x0B\x15_\x14a\x1B`W\x8A\x15a\x1B8Wa\x18]a\x18W`@\x9F\x9Ba\x19<\x9Ca\x19N\x9E[`\x01\x83\x01\x95a\x18O`\x02a\x18C\x84\x8AT\x85\x03aV\xB7V[\x95\x01\x92\x83T\x85\x03aV\xB7V[\x96UUa23V[\x91a23V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x9A\x8B\x96_\x84`\x0F\x0B\x12a\x1A\xCAW[P\x82`\x0F\x0Ba\x19\x86W[PPPa\x18\xB2a\x18\xA3\x85`\x80\x1D\x83`\x80\x1D\x01a8\\V[\x91\x85`\x0F\x0B\x90`\x0F\x0B\x01a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x91\x81Q`\x02\x0B\x90` \x83\x01Q`\x02\x0B\x8C\x84\x01Q``\x85\x01Q\x91\x8EQ\x94\x85R` \x85\x01R\x8D\x84\x01R``\x83\x01R\x7F\xF2\x08\xF4\x91'\x82\xFD%\xC7\xF1\x14\xCA7#\xA2\xD5\xDDo;\xCC:\xC8\xDBZ\xF6;\xAA\x85\xF7\x11\xD5\xEC`\x803\x93\xA3\x88s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x16a92V[\x80\x94\x91\x94a\x19ZW[P\x833\x91a7)V[\x82Q\x91\x82R` \x82\x01R\xF3[a\x19\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x84\x01Q\x16\x90\x83a7)V[\x85a\x19EV[`\x80QT\x92\x93P\x90\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90`\xA0\x1C`\x02\x0B\x82\x81\x12\x15a\x19\xECWPP\x90a\x19\xE0\x92a\x19\xD5a\x19\xCBa\x19\xDB\x94aAfV[\x91`\x0F\x0B\x92aAfV[\x90aE5V[a8\\V[`\x80\x1B[\x8B\x80\x80a\x18\x8CV[\x92\x80\x91\x93\x12_\x14a\x1A\x97Wa\x1A+\x91a\x1A\x18a\x19\xDBa\x19\xDB\x93a\x1A\x12\x88`\x0F\x0B\x91aAfV[\x87aE5V[\x93a\x1A&\x86`\x0F\x0B\x92aAfV[aD\xD8V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1Aj`\x03`\x80Q\x01\x92`\x0F\x0B\x82\x84T\x16aE|V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x19\xE4V[\x90a\x19\xDB\x92P\x92a\x1A\xADa\x19\xCBa\x1A\xB3\x95aAfV[\x90aD\xD8V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\xE4V[\x80\x8F\x91Qa\x1B\x0CW[\x01Qa\x1A\xE0W[\x8Ea\x18\x82V[a\x1B\x07\x82`\x80Q`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\xDAV[a\x1B3\x83`\x80Q`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\xD3V[\x7F\xAE\xFE\xB9$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x18]a\x18W`@\x9F\x9Ba\x19<\x9Ca\x19N\x9Eo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1B\x90\x89`\x0F\x0B\x83aE|V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84T\x16\x17\x83Ua\x18,V[\x90\x99\x90\x89\x13a\x1B\xE3W`\x02\x80`\x01\x8C\x01T`\x01\x84\x01T\x90\x03\x9B\x01T\x91\x01T\x90\x03\x9Ba\x17\x98V[\x98`\x02`\x01`\x80Q\x01T`\x01\x8C\x01T\x90\x03`\x01\x83\x01T\x90\x03\x9A\x81\x80`\x80Q\x01T\x91\x01T\x90\x03\x91\x01T\x90\x03\x9Ba\x17\x98V[`\x04`\x80Q\x01\x89`\x02\x0B_R\x80` R\x89\x89`@_ a\x1Cl\x81To\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1CO\x81\x83\x16\x95`\x0F\x0B\x86aE|V[\x16\x93\x15\x94\x85\x85\x15\x14\x15\x95a\x1E\xB6W[P\x8D`\x0F\x0B\x90`\x80\x1Da>\x11V[`\x80\x1B\x82\x17\x90U` \x87\x01R\x85R\x87`\x02\x0B_R` R`@_ \x80T\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16a\x1C\xAA\x8B`\x0F\x0B\x82aE|V[\x90\x15\x92\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15\x14\x15\x93a\x1E\x89W[\x8B`\x0F\x0B\x90`\x80\x1D`\x0F\x0B\x03\x91o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x12\x17a\x1E\\W\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93P`\x80\x1B\x83\x83\x16\x17\x90U\x16``\x86\x01R`@\x85\x01R_\x88`\x0F\x0B\x12\x15a\x1D\x8FW[\x83Qa\x1DsW[`@\x84\x01Q\x15a\x17HWa\x1Dn`\x80\x8C\x01Q`\x02\x0B\x88`\x05`\x80Q\x01aA\x1AV[a\x17HV[a\x1D\x8A`\x80\x8C\x01Q`\x02\x0B\x8A`\x05`\x80Q\x01aA\x1AV[a\x1DMV[`\x80\x8B\x01Q`\x02\x0Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01\x81` \x88\x01Q\x16\x92\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x05\x90b\r\x89\xE8\x05\x03\x01\x81\x04\x16\x80\x91\x11a\x1E0Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x86\x01Q\x16\x11\x15a\x1DFW\x86\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x89\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[`\x80QT`\xA0\x1C`\x02\x0B\x8B\x13a\x1C\xCAW`\x01`\x80Q\x01T`\x01\x84\x01U`\x02`\x80Q\x01T`\x02\x84\x01Ua\x1C\xCAV[`\x80QT`\xA0\x1C`\x02\x0B\x12\x15a\x1E\xCDW[\x8Ea\x1C^V[`\x01`\x80Q\x01T`\x01\x84\x01U`\x02`\x80Q\x01T`\x02\x84\x01Ua\x1E\xC7V[\x85\x7F\x1A\xD7w\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xD5\xE2\xF7\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[`D\x88\x87`@Q\x91\x7F\xC4C>\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x04\x83\x01R`$\x82\x01R\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_`@\x85\x01Q\x13\x80\x80\x91a rW[\x15a \x07WPP`@Q\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x1F\xFE\x91a\x12F\x82a\x12\x1A\x88\x87\x89\x8C3`$\x87\x01a7\xA2V[P[\x85\x80a\x16uV[\x15\x90\x81a dW[Pa \x1BW[Pa \0V[`@Q\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra ]\x91a\x12F\x82a\x12\x1A\x88\x87\x89\x8C3`$\x87\x01a7\xA2V[P\x85a \x15V[a\x02\0\x91P\x16\x15\x15\x87a \x0FV[Pa\x08\0\x82\x16\x15\x15a\x1F\xB5V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa \xB6a-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa \xD3a.\x15V[\x91\x16_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ `D5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa!Na-\xF2V[`$5\x90\x81\x15\x15\x80\x92\x03a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x903_R`\x03` R`@_ \x82\x82\x16_R` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16`\xFF\x85\x16\x17\x90U`@Q\x92\x83R\x16\x90\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` 3\x92\xA3` `@Q`\x01\x81R\xF3[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\"&6a/4V[a\".a/\"V[\x90b\x80\0\0b\xFF\xFF\xFF`@\x83\x01Q\x16\x14\x80\x15\x90a\"\xE2W[a\"\xBAW`\xA0\x90a\"V\x83a7eV[ _R`\x06` R`@_ \x90a\"l\x82a6MV[\x81T\x7F\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xD0\x91\x90\x91\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90U\0[\x7F0\xD2\x16A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x163\x14\x15a\"FV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa#U\x906\x90`\x04\x01a0\0V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\a%iWa#\xE1\x91_\x91`\x01\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]`@Q\x93\x84\x92\x83\x92\x7F\x91\xDDsF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R` `\x04\x85\x01R`$\x84\x01\x91a1\x1FV[\x03\x81\x833Z\xF1\x90\x81\x15a%^W_\x91a$\xB6W[P\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\a$\x8EW`@` \x91_\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[\x7FR\x12\xCB\xA1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P=\x80_\x83>a$\xC7\x81\x83a.\xE1V[\x81\x01\x90` \x81\x83\x03\x12a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x030W\x01\x81`\x1F\x82\x01\x12\x15a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1FyW`@Q\x92a%:` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x86\x01\x16\x01\x85a.\xE1V[\x82\x84R` \x83\x83\x01\x01\x11a\x030W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x81a#\xF5V[`@Q=_\x82>=\x90\xFD[\x7FP\x90\xD6\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa%\xB46a.8V[\x91\x92\x90\x923_R`\x05` R`@_ \x82\x82\x16_R` R`@_ \x84_R` R\x82`@_ U`@Q\x92\x83R\x16\x90\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` 3\x92\xA4` `@Q`\x01\x81R\xF3[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa&Ga-\xF2V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x07\xA2` \x91a5\x04V[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`$5`\x045`@Q\x91`@\x83` \x81R\x82` \x82\x01R\x01\x90`\x05\x1B\x83\x01\x91`\x01` `@\x85\x01\x93[\x83T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` `\x01\x91a&\xD1V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x030Wa'_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x163\x14a0\xBAV[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U\x7F\xB4\xBD\x8E\xF5=\xF6\x90\xB9\x94=3\x18\x99`\x06\xDB\xB8*%\xF5G\x19\xD8\xC8\x03[Qj*[\x8A\xCC_\x80\xA2\0[4a\x030Wa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa'\xE86a/4V[`\xC45\x90`\xA45`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa(\x0F\x906\x90`\x04\x01a0\0V[\x91\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa(Aa5\xE6V[`\xA0\x84 \x94\x85_R`\x06` R`@_ \x94a(\\\x86a6MV[`\x80\x81\x01\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a)\xF6W[PPo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x97\x88\x15a)\xCEW` \x98a(\xAE\x87a23V[_\x03a(\xB9\x87a23V[_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x98\x87a)\xBAW[\x86a)\xA5W[PPa(\xEC3\x89\x85a7)V[`@Q\x90\x86\x82R\x85\x8A\x83\x01R\x7F)\xEF\x05\xCA\xAF\xF9@K|\xB6\xD1\xC0\xE9\xBB\xAE\x9E\xAAz\xB2T\x1F\xEB\xA1\xA9\xC4$\x85\x94\xC0\x81V\xCB`@3\x93\xA3Q\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x843\x03a)JW[\x88\x88`@Q\x90\x81R\xF3[`\x10\x16a)XW[\x80a)@V[a)\x99\x95a\x12F\x93a\x12\x1A\x92`@Q\x97\x88\x95\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8D\x88\x01R3`$\x88\x01a6\x93V[P\x82\x80\x80\x80\x80\x80a)RV[`\x02\x01\x90\x86`\x80\x1B\x04\x81T\x01\x90U\x89\x80a(\xDFV[`\x01\x81\x01\x82\x89`\x80\x1B\x04\x81T\x01\x90Ua(\xD9V[\x7F\xA7O\x97\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x16a*\x04W[\x80a(\x82V[`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra*G\x91a\x12F\x82a\x12\x1A\x8B\x89\x8B\x8D\x8B3`$\x88\x01a6\x93V[P\x88a)\xFEV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045T_R` _\xF3[4a\x030Wa*\x966a.8V[\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEDs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80_\x94\x16\x95a+\x15a+\x08\x87a23V[\x86\x03`\x0F\x0B3\x90\x89a2yV[\x16\x93\x84\x84R`\x04` R`@\x84 \x86\x85R` R`@\x84 a\x02_\x82\x82Ta0\xADV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W` a\x07\xA23a5\x04V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa+\xCAa-\xF2V[a+\xD2a.\x15V[`D5\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\n\xA5\x92a,\x1Aa,\r\x84a23V[_\x03`\x0F\x0B3\x90\x83a2yV[a3\x81V[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa,B6a.8V[\x91\x92\x90\x923_R`\x04` R`@_ \x84_R` R`@_ a,g\x84\x82Ta0\xA0V[\x90U\x16\x90\x81_R`\x04` R`@_ \x83_R` R`@_ a,\x8C\x82\x82Ta0\xADV[\x90U`@\x80Q3\x80\x82R` \x82\x01\x93\x90\x93R\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\x91\x81\x90\x81\x01a\x02yV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x030W\x80\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a-^W[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x0Fc/\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a-SV[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa-\xD7a-\xF2V[\x16_R`\x04\x82R`@_ `$5_R\x82R`@_ T\x81R\xF3[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC``\x91\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x90`$5\x90`D5\x90V[`\x80\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[``\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[`\xA0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[`\xA45\x90b\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC`\xA0\x91\x01\x12a\x030W`@Q\x90a/k\x82a.\xC5V[\x81`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x030W`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x030W``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`\x80\x01RV[\x91\x81`\x1F\x84\x01\x12\x15a\x030W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x030W` \x83\x81\x86\x01\x95\x01\x01\x11a\x030WV[\x90` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030W\x82`#\x82\x01\x12\x15a\x030W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x030W`$\x84`\x05\x1B\x83\x01\x01\x11a\x030W`$\x01\x91\x90V[\x91\x90\x82\x03\x91\x82\x11a\x1E\\WV[\x91\x90\x82\x01\x80\x92\x11a\x1E\\WV[\x15a0\xC1WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FUNAUTHORIZED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[`\x1F\x82` \x94\x93\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x93\x81\x86R\x86\x86\x017_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9\\\x16a2\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x15a2\x07Wa1\xC0\x90a;iV[\x90\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9]\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95]V[PPV[\x7F\x99l\xAFe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a2QW`\x0F\x0B\x90V[\x7F\x93\xDA\xFD\xF1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x90`\x0F\x0B\x91\x82\x15a3|Wa2\xAF\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x92\x16_R\x16` R`@_ \x90V[a2\xBB\x81\\\x92\x83a<\0V[\x80\x91]a3,WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B][V[\x15a33WV[`\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B]V[PPPV[\x90\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81a4\x1FWPP_\x80\x80\x80\x93\x85Z\xF1\x15a3\xB3WPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=`@Q\x93\x7F\x85I\xDBY\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[` _`D\x81\x94\x96\x82`@\x95s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x98\x87Q\x99\x8A\x94\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R\x16`\x04\x85\x01R`$\x84\x01RZ\xF1=\x15`\x1F=\x11`\x01\x85Q\x14\x16\x17\x16\x92\x82\x81R\x82` \x82\x01R\x01R\x15a4\x98WPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=`@Q\x93\x7F\xB1,_\x9C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9\\\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a5YWa3*\x904\x93[a5S\x85a23V[\x90a2yV[4a5\xBEWa3*\x90a5\x95\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95\\a5\x90\x86a;iV[a0\xA0V[\x93_\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9]a5JV[\x7F\xB0\xEC\x84\x9E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a6%WV[\x7F\r\x89C\x8E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a6kWV[\x7FHj\xA3\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x92a7\x0Ea\x01 \x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa7&\x99\x97\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xC0\x83\x01R`\xE0\x82\x01R\x81a\x01\0\x82\x01R\x01\x91a1\x1FV[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` a3*\x94\x93a7X\x85\x84\x83Q\x16\x86`\x80\x1D\x90a2yV[\x01Q\x16\x90`\x0F\x0B\x90a2yV[b\xFF\xFF\xFF\x16b\x0FB@\x81\x11a7wWPV[\x7F\x14\0!\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90a7&\x95\x93a8\x1Fa\x01`\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa8N\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x85\x01R` \x82\x01Q\x90\x0B`\xE0\x84\x01R`@\x81\x01Qa\x01\0\x84\x01R``\x01Qa\x01 \x83\x01RV[\x81a\x01@\x82\x01R\x01\x91a1\x1FV[\x90\x81`\x0F\x0B\x91\x82\x03a2QWV[\x92a9\x18\x90a8\xE9a7&\x99\x97\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x01\xA0\x98\x95\x16\x87R` \x87\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x87\x01R` \x82\x01Q\x90\x0B`\xE0\x86\x01R`@\x81\x01Qa\x01\0\x86\x01R``\x01Qa\x01 \x85\x01RV[a\x01@\x83\x01Ra\x01`\x82\x01R\x81a\x01\x80\x82\x01R\x01\x91a1\x1FV[\x93\x95\x90\x91\x92\x96\x94_\x96s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x163\x14a:\x83W\x88_`@\x87\x01Q\x13_\x14a:\x12Wa\x04\0\x87\x16a9yW[PPPPPPPV[a:\x05\x97\x99\x98P\x92a9\xFE\x96\x95\x94\x92a9\xC6\x92a9\xF2\x95`@Q\x97\x88\x96\x7F\x9F\x06>\xFC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01a8jV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a.\xE1V[`\x02\x82\x16\x15\x15\x91aE\xADV[\x80\x92aE\xCDV[\x91_\x80\x80\x80\x80\x80\x80a9pV[\x95\x94\x93\x92\x91\x90a\x01\0\x86\x16a:*WPPPPPPPV[a:\x05\x97\x99P\x86\x98P\x91a9\xC6\x91a:w\x94\x93a9\xFE\x98`@Q\x97\x88\x96\x7Fl+\xBE~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01a8jV[`\x01\x82\x16\x15\x15\x91aE\xADV[P_\x96PPPPPPV[`\x80\x81\x16\x15\x80a;@W[a;\x16W`@\x81\x16\x15\x80a;4W[a;\x16Wa\x04\0\x81\x16\x15\x80a;(W[a;\x16Wa\x01\0\x81\x16\x15\x80a;\x1CW[a;\x16Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a:\xF6WPb\xFF\xFF\xFF\x16b\x80\0\0\x14\x15\x90V[a?\xFF\x16\x15\x90\x81\x15\x91a;\x07WP\x90V[b\x80\0\0\x91Pb\xFF\xFF\xFF\x16\x14\x90V[PP_\x90V[P`\x01\x81\x16\x15\x15a:\xC8V[P`\x02\x81\x16\x15\x15a:\xB8V[P`\x04\x81\x16\x15\x15a:\xA8V[P`\x08\x81\x16\x15\x15a:\x99V[b\x80\0\0b\xFF\xFF\xFF\x82\x16\x14a;dWa7&\x81a7eV[P_\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a;\x89WPG\x90V[` `$\x91`@Q\x92\x83\x80\x92\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R0`\x04\x83\x01RZ\xFA\x90\x81\x15a%^W_\x91a;\xD1WP\x90V[\x90P` \x81=` \x11a;\xF8W[\x81a;\xEC` \x93\x83a.\xE1V[\x81\x01\x03\x12a\x030WQ\x90V[=\x91Pa;\xDFV[\x91\x90\x91_\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x1E\\WV[` \x83\x01Q\x95_\x95\x86\x95\x91\x94\x913s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x14a>\x04W`\x80\x84\x16a<UW[PPPPPV[a==\x92a9\xC6a=7\x92a=#\x94`@Q\x95\x86\x94\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01Ra<\xED`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q\x15\x15`\xE4\x87\x01R` \x81\x01Qa\x01\x04\x87\x01R`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01$\x86\x01RV[a\x01@a\x01D\x85\x01Ra\x01d\x84\x01\x91a1\x1FV[\x82a?\xFCV[\x91``\x83Q\x03a=\xDCW`@\x01Qb\xFF\xFF\xFF\x16b\x80\0\0\x14a=\xD0W[`\x08\x16a=kW[\x80\x80\x80\x80a<NV[`@\x01Q\x92P`\x80\x83\x90\x1D`\x0F\x0B\x80\x15a=bWa=\x8C\x90_\x86\x12\x95a<\0V[\x93\x15a=\xC8W_\x84\x13[a=\xA0W_a=bV[\x7F\xFA\x0Bq\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x84\x12a=\x96V[``\x82\x01Q\x93Pa=ZV[\x7F\x1E\x04\x8E\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P_\x96P\x86\x95PPPPPV[\x90`\x0F\x0B\x90`\x0F\x0B\x01\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x12o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x17a\x1E\\WV[\x91\x96\x95\x93\x94\x92\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x163\x14a?\xEFW\x84`\x80\x1D\x94`\x0F\x0B\x93\x88`@\x85\x16a?\x17W[PPPPP_\x94\x81`\x0F\x0B\x15\x80\x15\x90a?\x0BW[a>\xAFW[PPP\x91\x90V[a>\xE6\x93\x95P_` \x82\x01Q\x12\x90Q\x15\x15\x14_\x14a>\xEEWo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17[\x80\x93aE\xCDV[_\x80\x80a>\xA8V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17a>\xDFV[P\x82`\x0F\x0B\x15\x15a>\xA3V[a?\xD3a?\xDF\x94a9\xC6a\x19\xDB\x95a?\xE5\x99\x98\x95a?\xB8a<\xED\x96`@Q\x97\x88\x96\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x8Ca\x01D\x85\x01Ra\x01`a\x01d\x85\x01Ra\x01\x84\x84\x01\x91a1\x1FV[`\x04\x82\x16\x15\x15\x91aE\xADV[\x90a>\x11V[_\x80\x80\x80\x88a>\x8FV[PPPPP\x90\x91P\x90_\x90V[\x91\x90\x91_\x80` \x85Q\x95\x01\x94\x85\x82\x85Z\xF1\x15a@\x98WP`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?=\x01\x16\x83\x01`@R=\x83R=\x90` \x84\x01\x91_\x83>` \x84Q\x10\x91\x82\x15a@dW[PPa=\xDCWV[Q\x90Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x91\x16\x14\x15\x90P_\x80a@\\V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x94\x7F1\x9DT\xC3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R\x16`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[\x91\x90`\x02\x0B\x90`\x02\x0B\x90\x81\x81\x07aAHW\x05\x90\x81`\x08\x1D_R` R`\x01`\xFF`@_ \x92\x16\x1B\x81T\x18\x90UV[`\x1C\x90`D\x92`@Q\x91c\xD4\xD8\xF3\xE6\x83R` \x83\x01R`@\x82\x01R\x01\xFD[`\x02\x0B\x90\x81`\xFF\x1D\x82\x81\x01\x18b\r\x89\xE8\x81\x11aD\xACWc\xFF\xFF\xFF\xFF\x91\x92`\x01\x82\x16p\x01\xFF\xFC\xB93\xBDo\xAD7\xAA-\x16-\x1AY@\x01\x02p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\x91`\x02\x81\x16aD\x90W[`\x04\x81\x16aDtW[`\x08\x81\x16aDXW[`\x10\x81\x16aD<W[` \x81\x16aD W[`@\x81\x16aD\x04W[`\x80\x81\x16aC\xE8W[a\x01\0\x81\x16aC\xCCW[a\x02\0\x81\x16aC\xB0W[a\x04\0\x81\x16aC\x94W[a\x08\0\x81\x16aCxW[a\x10\0\x81\x16aC\\W[a \0\x81\x16aC@W[a@\0\x81\x16aC$W[a\x80\0\x81\x16aC\x08W[b\x01\0\0\x81\x16aB\xECW[b\x02\0\0\x81\x16aB\xD1W[b\x04\0\0\x81\x16aB\xB6W[b\x08\0\0\x16aB\x9DW[_\x12aBvW[\x01` \x1C\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04aBoV[k\x04\x8A\x17\x03\x91\xF7\xDCBDN\x8F\xA2\x90\x91\x02`\x80\x1C\x90aBhV[m\"\x16\xE5\x84\xF5\xFA\x1E\xA9&\x04\x1B\xED\xFE\x98\x90\x92\x02`\x80\x1C\x91aB^V[\x91n]j\xF8\xDE\xDB\x81\x19f\x99\xC3)\"^\xE6\x04\x02`\x80\x1C\x91aBSV[\x91o\t\xAAP\x8B[z\x84\xE1\xC6w\xDET\xF3\xE9\x9B\xC9\x02`\x80\x1C\x91aBHV[\x91o1\xBE\x13_\x97\xD0\x8F\xD9\x81#\x15\x05T/\xCF\xA6\x02`\x80\x1C\x91aB=V[\x91op\xD8i\xA1V\xD2\xA1\xB8\x90\xBB=\xF6+\xAF2\xF7\x02`\x80\x1C\x91aB3V[\x91o\xA9\xF7FF-\x87\x0F\xDF\x8Ae\xDC\x1F\x90\xE0a\xE5\x02`\x80\x1C\x91aB)V[\x91o\xD0\x97\xF3\xBD\xFD \"\xB8\x84Z\xD8\xF7\x92\xAAX%\x02`\x80\x1C\x91aB\x1FV[\x91o\xE7\x15\x94u\xA2\xC2\x9BtC\xB2\x9C\x7F\xA6\xE8\x89\xD9\x02`\x80\x1C\x91aB\x15V[\x91o\xF39+\x08\"\xB7\0\x05\x94\x0Cz9\x8EKp\xF3\x02`\x80\x1C\x91aB\x0BV[\x91o\xF9\x87\xA7%:\xC4\x13\x17o+\x07L\xF7\x81^T\x02`\x80\x1C\x91aB\x01V[\x91o\xFC\xBE\x86\xC7\x90\n\x88\xAE\xDC\xFF\xC8;G\x9A\xA3\xA4\x02`\x80\x1C\x91aA\xF7V[\x91o\xFE]\xEE\x04j\x99\xA2\xA8\x11\xC4a\xF1\x96\x9C0S\x02`\x80\x1C\x91aA\xEDV[\x91o\xFF.\xA1df\xC9j8C\xECx\xB3&\xB5(a\x02`\x80\x1C\x91aA\xE4V[\x91o\xFF\x97;A\xFA\x98\xC0\x81G.h\x96\xDF\xB2T\xC0\x02`\x80\x1C\x91aA\xDBV[\x91o\xFF\xCB\x98C\xD6\x0FaY\xC9\xDBX\x83\\\x92fD\x02`\x80\x1C\x91aA\xD2V[\x91o\xFF\xE5\xCA\xCA~\x10\xE4\xE6\x1C6$\xEA\xA0\x94\x1C\xD0\x02`\x80\x1C\x91aA\xC9V[\x91o\xFF\xF2\xE5\x0F_ei2\xEF\x125|\xF3\xC7\xFD\xCC\x02`\x80\x1C\x91aA\xC0V[\x91o\xFF\xF9rr7=A2Y\xA4i\x90X\x0E!:\x02`\x80\x1C\x91aA\xB7V[\x82\x7F\x8B\x862z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90_\x83`\x0F\x0B\x12_\x14aE\rWaE\x03\x92_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aY\xF1V[_\x81\x12a2QW\x90V[aE)\x92o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aY\x96V[_\x81\x12a2QW_\x03\x90V[\x90_\x83`\x0F\x0B\x12_\x14aE`WaE\x03\x92_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ\xE8V[aE)\x92o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ1V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90`\x0F\x0B\x91\x16\x01\x90\x81`\x80\x1CaE\xA0WV[c\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x90aE\xB7\x91a?\xFCV[\x90\x15a;dW`@\x81Q\x03a=\xDCW`@\x01Q\x90V[aE\xF0\x90aE\xE2\x83`\x80\x1D\x82`\x80\x1D\x03a8\\V[\x92`\x0F\x0B\x90`\x0F\x0B\x03a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90V[s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DQc\x96\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFD\x89]\x83\x01\x16\x11aH\xEEWw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x81` \x1B\x16\x80`\xFFaF\x87\x83a[\x8FV[\x16\x91`\x80\x83\x10aH\xE2WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x82\x01\x1C[\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x90\x81`\x7F\x1C\x82`\xFF\x1C\x1C\x80\x02\x92\x83`\x7F\x1C\x84`\xFF\x1C\x1C\x80\x02\x94\x85`\x7F\x1C\x86`\xFF\x1C\x1C\x80\x02\x96\x87`\x7F\x1C\x88`\xFF\x1C\x1C\x80\x02\x98\x89`\x7F\x1C\x8A`\xFF\x1C\x1C\x80\x02\x9A\x8B`\x7F\x1C\x8C`\xFF\x1C\x1C\x80\x02\x9C\x8D\x80`\x7F\x1C\x90`\xFF\x1C\x1C\x80\x02`\xCD\x1Cf\x04\0\0\0\0\0\0\x16\x9D`\xCC\x1Cf\x08\0\0\0\0\0\0\x16\x9C`\xCB\x1Cf\x10\0\0\0\0\0\0\x16\x9B`\xCA\x1Cf \0\0\0\0\0\0\x16\x9A`\xC9\x1Cf@\0\0\0\0\0\0\x16\x99`\xC8\x1Cf\x80\0\0\0\0\0\0\x16\x98`\xC7\x1Cg\x01\0\0\0\0\0\0\0\x16\x97`\xC6\x1Cg\x02\0\0\0\0\0\0\0\x16\x96`\xC5\x1Cg\x04\0\0\0\0\0\0\0\x16\x95`\xC4\x1Cg\x08\0\0\0\0\0\0\0\x16\x94`\xC3\x1Cg\x10\0\0\0\0\0\0\0\x16\x93`\xC2\x1Cg \0\0\0\0\0\0\0\x16\x92`\xC1\x1Cg@\0\0\0\0\0\0\0\x16\x91`\xC0\x1Cg\x80\0\0\0\0\0\0\0\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x01`@\x1B\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17i6'\xA3\x01\xD7\x10UwL\x85\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFDp\x9B~T\x80\xFB\xA5\xA5\x0F\xED^b\xFF\xC5V\x81\x01`\x80\x1D`\x02\x0B\x90o\xDB-\xF0\x9E\x81\x95\x9A\x81E^&\x07\x99\xA0c/\x01`\x80\x1D`\x02\x0B\x91\x82\x82\x14_\x14aH\x9FWP\x90P\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaH\xD3\x84aAfV[\x16\x11aH\xDDWP\x90V[\x90P\x90V[\x90P\x81`\x7F\x03\x1BaF\xB7V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7FaHu$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[\x81\x15aI:W\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x90\x91_\x92`@Q\x91aIx\x83a.\xA9V[_\x83R_` \x84\x01R_`@\x84\x01R\x82\x94\x84T\x93` \x84\x01Q\x15\x93o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x90\x85\x15_\x14aV\xA9Wa\x0F\xFF\x87`\xB8\x1C\x16\x92[`@\x82\x01Q\x91_\x93\x88\x15_\x14aV\x9FW`\x01\x8B\x01T[\x97\x8As\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R\x8A`\xA0\x1C`\x02\x0B` \x85\x01R\x81`@\x85\x01R`\x80\x83\x01Qb@\0\0\x81\x16\x15\x15_\x14aV\x90Wb\xBF\xFF\xFF\x16aJ \x81a7eV[a\xFF\xFF\x88\x16aVmW\x91[\x82_`@\x86\x01Q\x12\x95b\x0FB@b\xFF\xFF\xFF\x83\x16\x10\x15aV@W[`@\x86\x01Q\x15aV(WPP\x8AaU\xB4W``\x84\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15aUgWPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16d\x01\0\x02v\xA3\x81\x11\x15aU<WP[`@Q\x9B\x8Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xE0\x82\x81\x81\x01\x10\x92\x01\x11\x17a\x1FyW\x95\x8E_`\xC0\x8F`\xE0\x81\x01`@R\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01R[\x81\x15\x90\x81\x15aU\x01W[PaS\xC8W\x8E\x8D\x8F\x8E\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84Q\x16\x83R` \x84\x01Q`\x02\x0B\x91\x89Q`\x02\x0B\x92\x83_\x81\x83\x07\x12\x91\x05\x03\x90\x15_\x14aRkW\x91\x82`\x05`\xFF\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95\x16\x93\x82`\x02\x0B`\x08\x1D`\x01\x0B_R\x01` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84`\xFF\x03\x1C\x90T\x16\x92\x83\x15\x15\x93\x84_\x14aRYW\x90aK\xD2`\xFF\x92a[\x8FV[\x90\x03\x16`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0B[\x90[\x15\x15`@\x84\x01R`\x02\x0B\x80` \x84\x01R\x13\x15aR-W[b\r\x89\xE8` \x82\x01Q`\x02\x0B\x12\x15aR\x1EW[\x8D`\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaL6` \x85\x01Q`\x02\x0BaAfV[\x16\x80``\x85\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x8C\x01Q\x16\x92\x83\x91\x15\x16\x81\x83\x10\x18\x91\x18\x02\x18o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x85\x01Q\x16b\xFF\xFF\xFF\x89\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x81\x10\x15\x91_\x88\x12_\x14aPyW\x84b\x0FB@\x03aL\xD2\x81\x8A_\x03aW9V[\x94\x84\x15aPhWaL\xE4\x83\x85\x83aZ1V[\x95[\x86\x81\x10aO\xADWP\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x93\x91`\x80\x95\x93\x97\x88\x91b\x0FB@\x82\x14_\x14aO\x9EWPP\x86[\x93[\x15aO\x90W\x91aM/\x92aY\xF1V[\x90[`\xC0\x83\x01R`\xA0\x82\x01R\x01R\x16\x90R\x85aOXW`\xA0\x8D\x01Q\x90_\x82\x12a2QW\x03\x95aMh\x8D`\xC0`\x80\x82\x01Q\x91\x01Q\x90a0\xADV[_\x81\x12a2QW\x88\x03\x97\x88\x13`\x01\x16a\x1E\\W\x8E\x8D\x8F\x8E[a\xFF\xFF\x8D\x16aO+W[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x85\x01Q\x16\x80aO\x18W[P\x8Es\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x86\x01Q\x16\x81\x14_\x14aN\xD7WP`@\x84\x01QaNGW[PPPP\x8D\x8D\x15_\x14aN;W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x01Q`\x02\x0B\x01`\x02\x0B[`\x02\x0B` \x82\x01R[\x96\x90\x96aK\x05V[` \x01Q`\x02\x0BaN*V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93`\x04aN\xB0\x94\x84\x15_\x14aN\xC9W` `\x02\x82\x01T\x93[\x01Q`\x02\x0B`\x02\x0B_R\x01` R`@_ \x91`\x01\x83\x01\x90\x81T\x90\x03\x90U`\x02\x82\x01\x90\x81T\x90\x03\x90UT`\x80\x1D\x90\x15aN\xBFW[\x82`@\x85\x01Q\x16aE|V[\x16`@\x82\x01R\x8D\x8F\x8E\x8EaM\xEFV[_\x03`\x0F\x0BaN\xA4V[` `\x01\x82\x01T\x94\x93aNpV[\x93\x91PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91PQ\x16\x81\x03aO\x01W[PaN3V[aO\n\x90aF\nV[`\x02\x0B` \x82\x01R_aN\xFBV[`\xC0\x84\x01Q`\x80\x1B\x04\x90\x9E\x01\x9D_aM\xA7V[\x9Cb\x0FB@\x8Da\xFF\xFF`\x80\x86\x01Q\x91\x16\x90`\xC0\x86\x01Q\x01\x02\x04\x90\x81`\xC0\x85\x01Q\x03`\xC0\x85\x01R\x01\x9CaM\x8AV[`\x80\x8D\x01Q`\xC0\x8E\x01Q\x01\x90_\x82\x12a2QW\x01\x95`\xA0\x8D\x01Q\x97_\x89\x12a2QW\x8F\x90\x8F\x8F\x91\x8F\x9BaO\x8A\x91a<\0V[\x9AaM\x80V[aO\x99\x92aZ\xE8V[aM/V[aO\xA8\x91\x89a\\\x1CV[aM\x1EV[\x96PPP\x91\x92P\x93\x83\x92\x82\x15\x86\x15\x17aP[Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x95`\x80\x93\x82\x15aO\xF6WaO\xEA\x87\x82\x84a\\\xBBV[\x80\x97\x8B\x01_\x03\x93aM V[\x87\x87\x11aP4WaP/aP*aP\"o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x8A``\x1BaI0V[\x8A\x85\x16a0\xADV[a]OV[aO\xEAV[aP/aP*aPVo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x8AaX>V[aP\"V[cO$a\xB8_R`\x04`\x1C\xFD[aPs\x83\x82\x86aY\x96V[\x95aL\xE6V[\x92\x94\x91\x93\x92\x84\x15aR\rWaP\x8F\x81\x83\x88aY\xF1V[\x95[\x86\x89\x10aP\xEAW`\x80\x93\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x92aP\xD7\x92\x80\x98[\x15aP\xDCW\x91aP\xC9\x92aZ1V[\x80\x95\x80b\x0FB@\x03\x91a\\\x1CV[aM1V[aP\xE5\x92aY\x96V[aP\xC9V[P\x94P\x90\x86\x85\x15\x83\x15\x17aP[W\x84\x15aQ\xE1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11aQ\x8EW\x87``\x1Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x16\x80\x82\x06\x15\x15\x91\x04\x01[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x81\x85\x11\x15aQ\x81Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x88aP\xD7\x93`\x80\x97\x03\x16[\x80\x98aP\xBAV[cC#\xA5U_R`\x04`\x1C\xFD[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x16aQ\xB9\x81l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x8BaX\xF7V[\x90\x80\x15aI:Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x8A\t\x15aQ9W`\x01\x01\x80aQ9W_\x80\xFD[aP\xD7\x83\x87aR\x08\x8Bs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x9A`\x80\x98a\\EV[aQzV[aR\x18\x81\x87\x84aZ\xE8V[\x95aP\x91V[` b\r\x89\xE8\x91\x01R\x8DaL\x0EV[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x91\x01R\x8DaK\xFBV[P`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0BaK\xE2V[`\x01`\x05\x91\x01\x91\x82`\x02\x0B`\x08\x1D`\x01\x0B_R\x01` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xFF\x84\x16\x1B\x01\x19\x90T\x16\x91\x82\x15\x91\x82\x15\x92\x83_\x14aS\x88Wa\x030W`\xFF\x84\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95_\x03\x16a\x01\xE0\x7F\x80@@UC\0RfD2\0\0P a\x06t\x050&\x02\0\0\x10u\x06 \x01v\x11pw`\xFC\x7F\xB6\xDBm\xB6\xDD\xDD\xDD\xDD\xD3M4\xD3I$\x92I!\x08B\x10\x8Cc\x18\xC69\xCEs\x9C\xFF\xFF\xFF\xFF\x84\x02`\xF8\x1C\x16\x1B`\xF7\x1C\x16~\x1F\r\x1E\x10\x0C\x1D\x07\x0F\t\x0B\x19\x13\x1C\x17\x06\x01\x0E\x11\x08\n\x1A\x14\x18\x02\x12\x1B\x15\x03\x16\x04\x05`\x1F\x85\x85\x16\x93\x83\x1Cc\xD7dS\xE0\x04\x16\x1A\x17\x03\x16`\x02\x0B\x90`\x02\x0B\x01`\x02\x0B\x02`\x02\x0B[\x90aK\xE4V[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x93P`\xFF\x81\x81\x16\x81\x03\x16`\x02\x0B\x90`\x02\x0B\x01`\x02\x0B\x02`\x02\x0BaS\x82V[\x97P\x91\x9AP\x9B\x98\x93\x9A\x91\x96\x9A\x97\x92\x94\x97` \x8A\x01Q`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8CQ\x16\x92\x16\x17\x17\x82Uo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8A\x01Q\x16\x80\x91\x03aT\xBCW[P\x82\x15aT\xB3W`\x02\x01U[\x15\x14aT\x9BW`@aTxaT\x81\x93\x94a8\\V[\x93\x01Q\x03a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x93V[aT\xAD\x90`@aT\x81\x93\x01Q\x03a8\\V[\x91a8\\V[`\x01\x01UaTcV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03\x83\x01T\x16\x17`\x03\x82\x01U_aTWV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91PQ\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x87\x01Q\x16\x14\x8FaK\x0FV[\x7F\x9EM|\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x8D`D\x91`@Q\x91\x7F|\x9Cn\x8F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x83\x01R`$\x82\x01R\xFD[``\x84\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aUgWPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DRc\x98\x8D&\x81\x10\x15aU<WPaJ\xB7V[\x9CP\x9CPP\x9BPPPPPPPPPP_\x92_\x92\x91\x90V[\x86aJEW\x7F\x96 bF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[b\xFF\xFF\xFFa\x0F\xFF\x89\x16\x91\x16\x80\x82\x02b\x0FB@\x80\x82\x06\x15\x15\x91\x04\x01\x91\x01\x03\x91aJ+V[P\x8A`\xD0\x1Cb\xFF\xFF\xFF\x16aJ V[`\x02\x8B\x01TaI\xD3V[a\x0F\xFF\x87`\xC4\x1C\x16\x92aI\xBDV[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14aW0Wp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\x80\x1B\x91\x03`\x80\x1C\x17\x90V[PPP`\x80\x1C\x90V[\x81\x81\x02\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x82\t\x90\x82\x80\x83\x10\x92\x03\x91\x80\x83\x03\x92\x83b\x0FB@\x11\x15a\x030W\x14aW\xB8W\x7F\xDE\x8Fl\xEF\xEDcEI\xB6,wWOr.\x1A\xC5~#\xF2M\x8F\xD5\xCBy\x0F\xB6Vh\xC2a9\x93b\x0FB@\x91\t\x90\x82\x82\x11\x90\x03`\xFA\x1B\x91\x03`\x06\x1C\x17\x02\x90V[PPb\x0FB@\x91P\x04\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14aX5Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\xA0\x1B\x91\x03``\x1C\x17\x90V[PPP``\x1C\x90V[\x90\x81``\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14aX\xF0Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[P\x91P\x04\x90V[\x91\x81\x83\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x85\t\x93\x83\x80\x86\x10\x95\x03\x94\x80\x86\x03\x95\x86\x85\x11\x15a\x030W\x14aY\x8EW\x90\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[PP\x91P\x04\x90V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`\x01\x95\x16\x91\x16\x03\x80`\xFF\x1D\x90\x81\x01\x18\x93\x16\x92aY\xE8\x81\x85aW\xC4V[\x93\t\x15\x15\x16\x01\x90V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80a7&\x95\x94\x16\x91\x16\x03\x80`\xFF\x1D\x90\x81\x01\x18\x91\x16aW\xC4V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x11aZ\xE2W[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x92\x83\x15aZ\xD6W{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaZ\xCA\x94\x81\x85\x16\x94\x03\x16\x91``\x1B\x16a\\\x1CV[\x90\x80\x82\x06\x15\x15\x91\x04\x01\x90V[b\xBF\xC9!_R`\x04`\x1C\xFD[\x90aZfV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x11a[\x89W[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x91\x82\x15aZ\xD6Wa7&\x93{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa[\x84\x94\x81\x85\x16\x94\x03\x16\x91``\x1B\x16aX\xF7V[aI0V[\x90a[\x1CV[\x80\x15a\x030W\x7F\x07\x06\x06\x05\x06\x02\x05\0\x06\x02\x03\x02\x05\x04\0\x01\x06\x05\x02\x05\x03\x03\x04\x01\x05\x05\x03\x04\0\0\0\0o\x84!\x08B\x10\x84!\x08\xCCc\x18\xC6\xDBmT\xBE\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x10`\x07\x1B\x83\x81\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x10`\x06\x1B\x17\x83\x81\x1Cc\xFF\xFF\xFF\xFF\x10`\x05\x1B\x17\x83\x81\x1Ca\xFF\xFF\x10`\x04\x1B\x17\x83\x81\x1C`\xFF\x10`\x03\x1B\x17\x92\x83\x1C\x1C`\x1F\x16\x1A\x17\x90V[\x92\x91\x90a\\*\x82\x82\x86aX\xF7V[\x93\x82\x15aI:W\ta\\8WV[\x90`\x01\x01\x90\x81\x15a\x030WV[\x91\x90\x81\x15a\\\xB6W{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91``\x1B\x16\x92\x16\x91\x82\x82\x02\x91\x83\x83\x83\x11\x91\x84\x04\x14\x16\x15a\\\xA9Wa7&\x92aP*\x92\x82\x03\x91a\\\x1CV[c\xF5\xC7\x87\xF1_R`\x04`\x1C\xFD[PP\x90V[\x90\x91\x80\x15a]IWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x81\x94``\x1B\x16\x92\x16\x80\x82\x02\x81a]\x0B\x84\x83aI0V[\x14a]1W[P\x90a] a]%\x92\x84aI0V[a0\xADV[\x80\x82\x06\x15\x15\x91\x04\x01\x16\x90V[\x83\x01\x83\x81\x10a]\x11W\x91Pa]E\x92a\\\x1CV[\x16\x90V[P\x90P\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x03a2QWV\xFE\xA1dsolcC\0\x08\x1A\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60a0806040526004361015610012575f80fd5b5f3560e01c908162fdd58e14612d885750806301ffc9a714612cc9578063095bcdb614612c1f5780630b0d9c0914612b9357806311da60b414612b38578063156e29f614612a885780631e2eaeaf14612a4e578063234266d7146127af5780632d771389146126ed57806335fd631a146126795780633dd45adb14612615578063426a84931461259157806348c894911461230657806352759651146121ee578063558a729714612117578063598af9e71461207f5780635a6bcfda1461153d578063695c5bf514610eac5780637e87ce7d14610d6f57806380f0b44c14610c9f5780638161b87414610ba75780638da5cb5b14610b5757806397e8cd4e14610af45780639bf6645f14610aa7578063a584119414610a66578063b6363cf2146109d5578063dbd035ff1461097f578063f02de3b21461092e578063f135baaa146108f4578063f2fde38b14610848578063f3cd914c146104ff578063f5298aca146103345763fe99049a14610186575f80fd5b346103305760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576101bd612df2565b6101c5612e15565b90604435917f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885961027973ffffffffffffffffffffffffffffffffffffffff80606435951693843314158061030d575b610287575b845f52600460205260405f20875f5260205260405f2061023a8782546130a0565b90551693845f52600460205260405f20865f5260205260405f2061025f8282546130ad565b905560408051338152602081019290925290918291820190565b0390a4602060405160018152f35b845f52600560205260405f208233165f5260205260405f20875f5260205260405f2054867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102da575b5050610219565b6102e3916130a0565b855f52600560205260405f208333165f5260205260405f20885f5260205260405f20555f866102d3565b50845f52600360205260405f208233165f5260205260ff60405f20541615610214565b5f80fd5b346103305761034236612e38565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ed73ffffffffffffffffffffffffffffffffffffffff805f9516956103bb6103b386613233565b339089613279565b169233841415806104a0575b6103f2575b8385526004602052604085208686526020526040852061025f8282546130a0565b0390a4005b83855260056020526040852073ffffffffffffffffffffffffffffffffffffffff33168652602052604085208686526020526040852054817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610459575b50506103cc565b610462916130a0565b84865260056020526040862073ffffffffffffffffffffffffffffffffffffffff331687526020526040862087875260205260408620558681610452565b5083855260036020526040852073ffffffffffffffffffffffffffffffffffffffff3316865260205260ff604086205416156103c7565b7f54e3ca0d000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761053836612f34565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c360112610330576040519061056f82612ea9565b60a4358015158103610330578252602082019060c435825260e4359073ffffffffffffffffffffffffffffffffffffffff8216820361033057604084019182526101043567ffffffffffffffff8111610330576105d0903690600401613000565b9290937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576106026135e6565b51156108205760a0822092835f52600660205260405f20906106238261364d565b60808401958482828a8a5173ffffffffffffffffffffffffffffffffffffffff169361064e94613c1b565b90949195606088015160020b968b511515915173ffffffffffffffffffffffffffffffffffffffff1691604051986106858a612ec5565b895260208901526040880152606087015262ffffff166080860152885115155f149862ffffff6107a2986106db61078f9860209d6108005773ffffffffffffffffffffffffffffffffffffffff8b511695614967565b9492968291926107d3575b505073ffffffffffffffffffffffffffffffffffffffff845116938e6fffffffffffffffffffffffffffffffff60408301511691015160020b90604051958860801d600f0b875288600f0b60208801526040870152606086015260808501521660a08301527f40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f60c03393a38673ffffffffffffffffffffffffffffffffffffffff8a5116613e58565b809491946107aa575b5050823391613729565b604051908152f35b73ffffffffffffffffffffffffffffffffffffffff6107cc9251169083613729565b8480610798565b73ffffffffffffffffffffffffffffffffffffffff165f5260018f5260405f209081540190558e806106e6565b73ffffffffffffffffffffffffffffffffffffffff8e8c01511695614967565b7fbe8b8507000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fffffffffffffffffffffffff00000000000000000000000000000000000000006108a0612df2565b73ffffffffffffffffffffffffffffffffffffffff5f54916108c582841633146130ba565b1691829116175f55337f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004355c5f5260205ff35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b346103305761098d3661302e565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355481520191019084838210156109cc5750602080916109b0565b60408186030190f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610a0c612df2565b73ffffffffffffffffffffffffffffffffffffffff610a29612e15565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060ff60405f2054166040519015158152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610aa5610aa0612df2565b61315d565b005b3461033057610ab53661302e565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355c81520191019084838210156109cc575060208091610ad8565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305773ffffffffffffffffffffffffffffffffffffffff610b40612df2565b165f526001602052602060405f2054604051908152f35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610bde612df2565b610be6612e15565b9060443573ffffffffffffffffffffffffffffffffffffffff600254163303610c77576020926107a29180610c6f575073ffffffffffffffffffffffffffffffffffffffff81165f526001845260405f20549283915b73ffffffffffffffffffffffffffffffffffffffff81165f526001865260405f20610c688482546130a0565b9055613381565b928391610c3c565b7f48f5c3ed000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610cd6612df2565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d757335f90815273ffffffffffffffffffffffffffffffffffffffff8216602052604090205c610d2c602435613233565b9081600f0b03610d4757610aa59133915f03600f0b90613279565b7fbda73abf000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610da736612f34565b610daf612f22565b9073ffffffffffffffffffffffffffffffffffffffff600254163303610c77576103e9610fff831610623e900062fff0008416101615610e7b57602060a07fe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9922092835f526006825260405f20610e258161364d565b805479ffffff00000000000000000000000000000000000000000000008360b81b16907fffffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffff1617905562ffffff60405191168152a2005b62ffffff827fa7abe2f7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b346103305760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610ee436612f34565b60a4359073ffffffffffffffffffffffffffffffffffffffff82168083036103305760c43567ffffffffffffffff811161033057610f26903690600401613000565b90610f2f6135e6565b6060840193845160020b617fff81136115125750845160020b600181126114e7575073ffffffffffffffffffffffffffffffffffffffff81511692602082019373ffffffffffffffffffffffffffffffffffffffff855116808210156114b05750506080820173ffffffffffffffffffffffffffffffffffffffff815116956040840196610fc362ffffff89511682613a8e565b156114855750610fd862ffffff885116613b4c565b91805173ffffffffffffffffffffffffffffffffffffffff8116908133036113c2575b505060a08520955f73ffffffffffffffffffffffffffffffffffffffff600254168061127e575b50875f52600660205260405f2090815473ffffffffffffffffffffffffffffffffffffffff166112565773ffffffffffffffffffffffffffffffffffffffff7fdd466e674ea557f56295e2d0218a125ea4b4f0f6f3307b95f85e6110838d64389860a09860209f98839662ffffff9685966110ba7cffffff00000000000000000000000000000000000000000000000000009d61460a565b9c8d9460d01b169079ffffff00000000000000000000000000000000000000000000008f76ffffff00000000000000000000000000000000000000008f9188901b16179160b81b16171790558851908a86831692833303611154575b5050505050505116995116995116995160020b91511690604051998a528a8a01526040890152606088015260020b95866080820152a4604051908152f35b61100016611163575b81611116565b61121a6112469261124b96604051966020947fa910f80f0000000000000000000000000000000000000000000000000000000089968701523360248701526111f8604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60e486015260020b61010485015261012061012485015261014484019161311f565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101845283612ee1565b613ffc565b508f8881808a61115d565b7f7983c051000000000000000000000000000000000000000000000000000000005f5260045ffd5b90505a907f000000000000000000000000000000000000000000000000000000000000000080921061139a576020915f918260405191858301927f553bfc370000000000000000000000000000000000000000000000000000000084526113338d602483019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60a4815261134260c482612ee1565b5193f15f519060203d14168061138c575b80611371575b1561136a5762ffffff165b8c611022565b505f611364565b506103e9610fff821610623e900062fff00083161016611359565b5062ffffff81168114611353565b7f1ee49702000000000000000000000000000000000000000000000000000000005f5260045ffd5b612000166113d1575b80610ffb565b61147e90604051907f3440d82000000000000000000000000000000000000000000000000000000000602083015233602483015261145c604483018973ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8460e48301526101006101048301526112468261121a61012482018a8d61311f565b508a6113cb565b7fe65af6a0000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b60449250604051917f6e6c983000000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b7fe9e90588000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fb70024f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b34610330576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761157636612f34565b60807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c36011261033057604051906115ad82612e8d565b60a4358060020b810361033057825260c4358060020b810361033057602083015260e43560408301526101043560608301526101243567ffffffffffffffff811161033057611600903690600401613000565b90927fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576116316135e6565b60a0832093845f52600660205260405f2060805261165060805161364d565b608084015173ffffffffffffffffffffffffffffffffffffffff811690813303611fa6575b5050815160020b92602083015160020b91611693604085015161385c565b93606087015160020b9760608201516040519960c08b018b811067ffffffffffffffff821117611f7957604052338b528860208c01528660408c015287600f0b60608c015260808b015260a08a01525f9185881215611f42577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276188812611f1657620d89e88613611eea576040519261172a84612e8d565b5f84525f60208501525f60408501525f606085015287600f0b611c13575b600460805101978960020b5f528860205260405f20988860020b5f5260205260405f206080515460a01c60020b8b81125f14611bbd575060028060018c0154600184015490039b015491015490039b5b60a073ffffffffffffffffffffffffffffffffffffffff825116910151906040519160268301528960068301528b600383015281525f603a600c83012091816040820152816020820152525f5260066080510160205260405f20976fffffffffffffffffffffffffffffffff8954169982600f0b155f14611b60578a15611b385761185d61185760409f9b61193c9c61194e9e5b600183019561184f6002611843848a5485036156b7565b950192835485036156b7565b965555613233565b91613233565b6fffffffffffffffffffffffffffffffff169060801b179a8b965f84600f0b12611aca575b5082600f0b611986575b5050506118b26118a38560801d8360801d0161385c565b9185600f0b90600f0b0161385c565b6fffffffffffffffffffffffffffffffff169060801b1791815160020b90602083015160020b8c8401516060850151918e5194855260208501528d84015260608301527ff208f4912782fd25c7f114ca3723a2d5dd6f3bcc3ac8db5af63baa85f711d5ec60803393a38873ffffffffffffffffffffffffffffffffffffffff608082015116613932565b8094919461195a575b50833391613729565b82519182526020820152f35b6119809073ffffffffffffffffffffffffffffffffffffffff6080840151169083613729565b85611945565b60805154929350909173ffffffffffffffffffffffffffffffffffffffff81169060a01c60020b828112156119ec575050906119e0926119d56119cb6119db94614166565b91600f0b92614166565b90614535565b61385c565b60801b5b8b808061188c565b92809193125f14611a9757611a2b91611a186119db6119db93611a1288600f0b91614166565b87614535565b93611a2686600f0b92614166565b6144d8565b6fffffffffffffffffffffffffffffffff169060801b17906fffffffffffffffffffffffffffffffff611a6a60036080510192600f0b8284541661457c565b167fffffffffffffffffffffffffffffffff000000000000000000000000000000008254161790556119e4565b906119db925092611aad6119cb611ab395614166565b906144d8565b6fffffffffffffffffffffffffffffffff166119e4565b808f9151611b0c575b0151611ae0575b8e611882565b611b078260805160049160020b5f52016020525f6002604082208281558260018201550155565b611ada565b611b338360805160049160020b5f52016020525f6002604082208281558260018201550155565b611ad3565b7faefeb924000000000000000000000000000000000000000000000000000000005f5260045ffd5b61185d61185760409f9b61193c9c61194e9e6fffffffffffffffffffffffffffffffff611b9089600f0b8361457c565b167fffffffffffffffffffffffffffffffff0000000000000000000000000000000084541617835561182c565b9099908913611be35760028060018c0154600184015490039b015491015490039b611798565b9860026001608051015460018c01549003600183015490039a81806080510154910154900391015490039b611798565b6004608051018960020b5f5280602052898960405f20611c6c81546fffffffffffffffffffffffffffffffff611c4f81831695600f0b8661457c565b16931594858515141595611eb6575b508d600f0b9060801d613e11565b60801b82179055602087015285528760020b5f5260205260405f208054906fffffffffffffffffffffffffffffffff8216611caa8b600f0b8261457c565b901592836fffffffffffffffffffffffffffffffff831615141593611e89575b8b600f0b9060801d600f0b03916f7fffffffffffffffffffffffffffffff83137fffffffffffffffffffffffffffffffff80000000000000000000000000000000841217611e5c57826fffffffffffffffffffffffffffffffff935060801b83831617905516606086015260408501525f88600f0b1215611d8f575b8351611d73575b60408401511561174857611d6e60808c015160020b8860056080510161411a565b611748565b611d8a60808c015160020b8a60056080510161411a565b611d4d565b60808b015160020b6fffffffffffffffffffffffffffffffff60018160208801511692807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276180590620d89e8050301810416809111611e30576fffffffffffffffffffffffffffffffff6060860151161115611d4657867fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b897fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6080515460a01c60020b8b13611cca57600160805101546001840155600260805101546002840155611cca565b6080515460a01c60020b1215611ecd575b8e611c5e565b600160805101546001840155600260805101546002840155611ec7565b857f1ad777f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fd5e2f7ab000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b60448887604051917fc4433ed500000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f604085015113808091612072575b156120075750506040517f259982e5000000000000000000000000000000000000000000000000000000006020820152611ffe916112468261121a8887898c33602487016137a2565b505b8580611675565b159081612064575b5061201b575b50612000565b6040517f21d0ee7000000000000000000000000000000000000000000000000000000000602082015261205d916112468261121a8887898c33602487016137a2565b5085612015565b61020091501615158761200f565b5061080082161515611fb5565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576120b6612df2565b73ffffffffffffffffffffffffffffffffffffffff6120d3612e15565b91165f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f52602052602060405f2054604051908152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761214e612df2565b602435908115158092036103305773ffffffffffffffffffffffffffffffffffffffff90335f52600360205260405f208282165f5260205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff851617905560405192835216907fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa26760203392a3602060405160018152f35b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761222636612f34565b61222e612f22565b906280000062ffffff604083015116148015906122e2575b6122ba5760a09061225683613765565b205f52600660205260405f209061226c8261364d565b81547fffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff1660d09190911b7cffffff000000000000000000000000000000000000000000000000000016179055005b7f30d21641000000000000000000000000000000000000000000000000000000005f5260045ffd5b5073ffffffffffffffffffffffffffffffffffffffff608082015116331415612246565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043567ffffffffffffffff811161033057612355903690600401613000565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c612569576123e1915f9160017fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d60405193849283927f91dd734600000000000000000000000000000000000000000000000000000000845260206004850152602484019161311f565b038183335af190811561255e575f916124b6575b507f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c61248e5760406020915f7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f835194859381855280519182918282880152018686015e5f85828601015201168101030190f35b7f5212cba1000000000000000000000000000000000000000000000000000000005f5260045ffd5b90503d805f833e6124c78183612ee1565b8101906020818303126103305780519067ffffffffffffffff8211610330570181601f820112156103305780519067ffffffffffffffff8211611f79576040519261253a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8601160185612ee1565b8284526020838301011161033057815f9260208093018386015e83010152816123f5565b6040513d5f823e3d90fd5b7f5090d6c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305773ffffffffffffffffffffffffffffffffffffffff6125b436612e38565b91929092335f52600560205260405f208282165f5260205260405f20845f526020528260405f205560405192835216907fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760203392a4602060405160018152f35b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612647612df2565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576107a2602091613504565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576024356004356040519160408360208152826020820152019060051b8301916001602060408501935b835481520191019084838210156109cc575060206001916126d1565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043573ffffffffffffffffffffffffffffffffffffffff81168091036103305761275f73ffffffffffffffffffffffffffffffffffffffff5f541633146130ba565b807fffffffffffffffffffffffff000000000000000000000000000000000000000060025416176002557fb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc5f80a2005b34610330576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576127e836612f34565b60c4359060a43560e43567ffffffffffffffff81116103305761280f903690600401613000565b9190937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7576128416135e6565b60a0842094855f52600660205260405f209461285c8661364d565b60808101805173ffffffffffffffffffffffffffffffffffffffff8116908133036129f6575b50506fffffffffffffffffffffffffffffffff6003880154169788156129ce576020986128ae87613233565b5f036128b987613233565b5f036fffffffffffffffffffffffffffffffff169060801b1798876129ba575b866129a5575b50506128ec338985613729565b60405190868252858a8301527f29ef05caaff9404b7cb6d1c0e9bbae9eaa7ab2541feba1a9c4248594c08156cb60403393a3519273ffffffffffffffffffffffffffffffffffffffff84169384330361294a575b8888604051908152f35b601016612958575b80612940565b612999956112469361121a926040519788957fe1b4af69000000000000000000000000000000000000000000000000000000008d8801523360248801613693565b50828080808080612952565b600201908660801b04815401905589806128df565b60018101828960801b0481540190556128d9565b7fa74f97ab000000000000000000000000000000000000000000000000000000005f5260045ffd5b602016612a04575b80612882565b6040517fb6a8b0fa000000000000000000000000000000000000000000000000000000006020820152612a47916112468261121a8b898b8d8b3360248801613693565b50886129fe565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057600435545f5260205ff35b3461033057612a9636612e38565b907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d7577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ed73ffffffffffffffffffffffffffffffffffffffff805f941695612b15612b0887613233565b8603600f0b339089613279565b16938484526004602052604084208685526020526040842061025f8282546130ad565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d75760206107a233613504565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612bca612df2565b612bd2612e15565b604435907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d757610aa592612c1a612c0d84613233565b5f03600f0b339083613279565b613381565b346103305773ffffffffffffffffffffffffffffffffffffffff612c4236612e38565b91929092335f52600460205260405f20845f5260205260405f20612c678482546130a0565b90551690815f52600460205260405f20835f5260205260405f20612c8c8282546130ad565b9055604080513380825260208201939093527f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288599181908101610279565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361033057807f01ffc9a70000000000000000000000000000000000000000000000000000000060209214908115612d5e575b506040519015158152f35b7f0f632fb30000000000000000000000000000000000000000000000000000000091501482612d53565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760209073ffffffffffffffffffffffffffffffffffffffff612dd7612df2565b165f526004825260405f206024355f52825260405f20548152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126103305760043573ffffffffffffffffffffffffffffffffffffffff8116810361033057906024359060443590565b6080810190811067ffffffffffffffff821117611f7957604052565b6060810190811067ffffffffffffffff821117611f7957604052565b60a0810190811067ffffffffffffffff821117611f7957604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611f7957604052565b60a4359062ffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60a09101126103305760405190612f6b82612ec5565b8160043573ffffffffffffffffffffffffffffffffffffffff8116810361033057815260243573ffffffffffffffffffffffffffffffffffffffff8116810361033057602082015260443562ffffff811681036103305760408201526064358060020b81036103305760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036103305760800152565b9181601f840112156103305782359167ffffffffffffffff8311610330576020838186019501011161033057565b9060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126103305760043567ffffffffffffffff811161033057826023820112156103305780600401359267ffffffffffffffff84116103305760248460051b83010111610330576024019190565b91908203918211611e5c57565b91908201809211611e5c57565b156130c157565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152fd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b73ffffffffffffffffffffffffffffffffffffffff7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95c1661320b5773ffffffffffffffffffffffffffffffffffffffff8116908115613207576131c090613b69565b907f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95d7f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955d565b5050565b7f996caf65000000000000000000000000000000000000000000000000000000005f5260045ffd5b6f8000000000000000000000000000000081101561325157600f0b90565b7f93dafdf1000000000000000000000000000000000000000000000000000000005f5260045ffd5b9190600f0b91821561337c576132af919073ffffffffffffffffffffffffffffffffffffffff8092165f521660205260405f2090565b6132bb815c9283613c00565b80915d61332c57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d5b565b1561333357565b60017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d565b505050565b90919073ffffffffffffffffffffffffffffffffffffffff8116908161341f5750505f80808093855af1156133b35750565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d604051937f8549db59000000000000000000000000000000000000000000000000000000008552600485015260406024850152806044850152805f606486013e011660640190fd5b60205f60448194968260409573ffffffffffffffffffffffffffffffffffffffff988751998a947fa9059cbb00000000000000000000000000000000000000000000000000000000865216600485015260248401525af13d15601f3d116001855114161716928281528260208201520152156134985750565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d604051937fb12c5f9c000000000000000000000000000000000000000000000000000000008552600485015260406024850152806044850152805f606486013e011660640190fd5b7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95c919073ffffffffffffffffffffffffffffffffffffffff83166135595761332a9034935b61355385613233565b90613279565b346135be5761332a906135957f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955c61359086613b69565b6130a0565b935f7f27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b95d61354a565b7fb0ec849e000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361362557565b7f0d89438e000000000000000000000000000000000000000000000000000000005f5260045ffd5b5473ffffffffffffffffffffffffffffffffffffffff161561366b57565b7f486aa307000000000000000000000000000000000000000000000000000000005f5260045ffd5b919261370e6101209473ffffffffffffffffffffffffffffffffffffffff613726999794168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60c083015260e082015281610100820152019161311f565b90565b9073ffffffffffffffffffffffffffffffffffffffff602061332a949361375885848351168660801d90613279565b01511690600f0b90613279565b62ffffff16620f424081116137775750565b7f14002113000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b90613726959361381f6101609473ffffffffffffffffffffffffffffffffffffffff61384e94168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08501526020820151900b60e0840152604081015161010084015260600151610120830152565b81610140820152019161311f565b9081600f0b91820361325157565b92613918906138e961372699979473ffffffffffffffffffffffffffffffffffffffff6101a09895168752602087019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08701526020820151900b60e0860152604081015161010086015260600151610120850152565b61014083015261016082015281610180820152019161311f565b939590919296945f9673ffffffffffffffffffffffffffffffffffffffff86163314613a8357885f6040870151135f14613a12576104008716613979575b50505050505050565b613a0597999850926139fe969594926139c6926139f2956040519788967f9f063efc000000000000000000000000000000000000000000000000000000006020890152336024890161386a565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282612ee1565b600282161515916145ad565b80926145cd565b915f808080808080613970565b9594939291906101008616613a2a5750505050505050565b613a05979950869850916139c691613a7794936139fe986040519788967f6c2bbe7e000000000000000000000000000000000000000000000000000000006020890152336024890161386a565b600182161515916145ad565b505f96505050505050565b608081161580613b40575b613b1657604081161580613b34575b613b165761040081161580613b28575b613b165761010081161580613b1c575b613b165773ffffffffffffffffffffffffffffffffffffffff8116613af6575062ffffff1662800000141590565b613fff161590811591613b07575090565b62800000915062ffffff161490565b50505f90565b50600181161515613ac8565b50600281161515613ab8565b50600481161515613aa8565b50600881161515613a99565b6280000062ffffff821614613b645761372681613765565b505f90565b73ffffffffffffffffffffffffffffffffffffffff1680613b8957504790565b6020602491604051928380927f70a082310000000000000000000000000000000000000000000000000000000082523060048301525afa90811561255e575f91613bd1575090565b90506020813d602011613bf8575b81613bec60209383612ee1565b81010312610330575190565b3d9150613bdf565b9190915f8382019384129112908015821691151617611e5c57565b6020830151955f9586959194913373ffffffffffffffffffffffffffffffffffffffff851614613e045760808416613c55575b5050505050565b613d3d926139c6613d3792613d23946040519586947f575e24b4000000000000000000000000000000000000000000000000000000006020870152336024870152613ced604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051151560e487015260208101516101048701526040015173ffffffffffffffffffffffffffffffffffffffff16610124860152565b61014061014485015261016484019161311f565b82613ffc565b916060835103613ddc576040015162ffffff166280000014613dd0575b600816613d6b575b80808080613c4e565b604001519250608083901d600f0b8015613d6257613d8c905f861295613c00565b9315613dc8575f84135b613da0575f613d62565b7ffa0b71d6000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f8412613d96565b60608201519350613d5a565b7f1e048e1d000000000000000000000000000000000000000000000000000000005f5260045ffd5b505f965086955050505050565b90600f0b90600f0b01907fffffffffffffffffffffffffffffffff8000000000000000000000000000000082126f7fffffffffffffffffffffffffffffff831317611e5c57565b9196959394929473ffffffffffffffffffffffffffffffffffffffff83163314613fef578460801d94600f0b938860408516613f17575b50505050505f9481600f0b15801590613f0b575b613eaf575b5050509190565b613ee69395505f60208201511290511515145f14613eee576fffffffffffffffffffffffffffffffff169060801b175b80936145cd565b5f8080613ea8565b906fffffffffffffffffffffffffffffffff169060801b17613edf565b5082600f0b1515613ea3565b613fd3613fdf946139c66119db95613fe5999895613fb8613ced966040519788967fb47b2fb1000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8c61014485015261016061016485015261018484019161311f565b600482161515916145ad565b90613e11565b5f80808088613e8f565b5050505050909150905f90565b9190915f80602085519501948582855af1156140985750604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f3d011683016040523d83523d9060208401915f833e6020845110918215614064575b5050613ddc57565b5190517fffffffff000000000000000000000000000000000000000000000000000000009182169116141590505f8061405c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f3d73ffffffffffffffffffffffffffffffffffffffff604051947f319d54c300000000000000000000000000000000000000000000000000000000865216600485015260406024850152806044850152805f606486013e011660640190fd5b919060020b9060020b908181076141485705908160081d5f52602052600160ff60405f2092161b8154189055565b601c906044926040519163d4d8f3e683526020830152604082015201fd5b60020b908160ff1d82810118620d89e881116144ac5763ffffffff9192600182167001fffcb933bd6fad37aa2d162d1a59400102700100000000000000000000000000000000189160028116614490575b60048116614474575b60088116614458575b6010811661443c575b60208116614420575b60408116614404575b608081166143e8575b61010081166143cc575b61020081166143b0575b6104008116614394575b6108008116614378575b611000811661435c575b6120008116614340575b6140008116614324575b6180008116614308575b6201000081166142ec575b6202000081166142d1575b6204000081166142b6575b620800001661429d575b5f12614276575b0160201c90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0461426f565b6b048a170391f7dc42444e8fa290910260801c90614268565b6d2216e584f5fa1ea926041bedfe9890920260801c9161425e565b916e5d6af8dedb81196699c329225ee6040260801c91614253565b916f09aa508b5b7a84e1c677de54f3e99bc90260801c91614248565b916f31be135f97d08fd981231505542fcfa60260801c9161423d565b916f70d869a156d2a1b890bb3df62baf32f70260801c91614233565b916fa9f746462d870fdf8a65dc1f90e061e50260801c91614229565b916fd097f3bdfd2022b8845ad8f792aa58250260801c9161421f565b916fe7159475a2c29b7443b29c7fa6e889d90260801c91614215565b916ff3392b0822b70005940c7a398e4b70f30260801c9161420b565b916ff987a7253ac413176f2b074cf7815e540260801c91614201565b916ffcbe86c7900a88aedcffc83b479aa3a40260801c916141f7565b916ffe5dee046a99a2a811c461f1969c30530260801c916141ed565b916fff2ea16466c96a3843ec78b326b528610260801c916141e4565b916fff973b41fa98c081472e6896dfb254c00260801c916141db565b916fffcb9843d60f6159c9db58835c9266440260801c916141d2565b916fffe5caca7e10e4e61c3624eaa0941cd00260801c916141c9565b916ffff2e50f5f656932ef12357cf3c7fdcc0260801c916141c0565b916ffff97272373d413259a46990580e213a0260801c916141b7565b827f8b86327a000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b905f83600f0b125f1461450d57614503925f036fffffffffffffffffffffffffffffffff16916159f1565b5f81126132515790565b614529926fffffffffffffffffffffffffffffffff1691615996565b5f8112613251575f0390565b905f83600f0b125f1461456057614503925f036fffffffffffffffffffffffffffffffff1691615ae8565b614529926fffffffffffffffffffffffffffffffff1691615a31565b906fffffffffffffffffffffffffffffffff90600f0b911601908160801c6145a057565b6393dafdf15f526004601cfd5b906145b791613ffc565b9015613b64576040815103613ddc576040015190565b6145f0906145e28360801d8260801d0361385c565b92600f0b90600f0b0361385c565b6fffffffffffffffffffffffffffffffff169060801b1790565b73fffd8963efd1fc6a506488495d951d516396168273ffffffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffefffd895d830116116148ee5777ffffffffffffffffffffffffffffffffffffffff000000008160201b168060ff61468783615b8f565b1691608083106148e257507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8182011c5b800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c80029081607f1c8260ff1c1c80029283607f1c8460ff1c1c80029485607f1c8660ff1c1c80029687607f1c8860ff1c1c80029889607f1c8a60ff1c1c80029a8b607f1c8c60ff1c1c80029c8d80607f1c9060ff1c1c800260cd1c6604000000000000169d60cc1c6608000000000000169c60cb1c6610000000000000169b60ca1c6620000000000000169a60c91c6640000000000000169960c81c6680000000000000169860c71c670100000000000000169760c61c670200000000000000169660c51c670400000000000000169560c41c670800000000000000169460c31c671000000000000000169360c21c672000000000000000169260c11c674000000000000000169160c01c67800000000000000016907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800160401b1717171717171717171717171717693627a301d71055774c85027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc556810160801d60020b906fdb2df09e81959a81455e260799a0632f0160801d60020b918282145f1461489f5750905090565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff6148d384614166565b16116148dd575090565b905090565b905081607f031b6146b7565b73ffffffffffffffffffffffffffffffffffffffff907f61487524000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b811561493a570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b90915f926040519161497883612ea9565b5f83525f60208401525f60408401528294845493602084015115936fffffffffffffffffffffffffffffffff6003880154169085155f146156a957610fff8760b81c16925b6040820151915f9388155f1461569f5760018b01545b978a73ffffffffffffffffffffffffffffffffffffffff1684528a60a01c60020b6020850152816040850152608083015162400000811615155f146156905762bfffff16614a2081613765565b61ffff881661566d57915b825f60408601511295620f424062ffffff83161015615640575b6040860151156156285750508a6155b4576060840173ffffffffffffffffffffffffffffffffffffffff8151168d73ffffffffffffffffffffffffffffffffffffffff1681101561556757505173ffffffffffffffffffffffffffffffffffffffff166401000276a381111561553c57505b6040519b8c67ffffffffffffffff60e0828181011092011117611f7957958e5f60c08f60e081016040528281528260208201528260408201528260608201528260808201528260a082015201525b8115908115615501575b506153c8578e8d8f8e9073ffffffffffffffffffffffffffffffffffffffff8451168352602084015160020b91895160020b92835f8183071291050390155f1461526b579182600560ff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189516938260020b60081d60010b5f520160205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8460ff031c9054169283151593845f146152595790614bd260ff92615b8f565b90031660020b900360020b0260020b5b905b1515604084015260020b806020840152131561522d575b620d89e8602082015160020b121561521e575b8d600173ffffffffffffffffffffffffffffffffffffffff614c36602085015160020b614166565b1680606085015273ffffffffffffffffffffffffffffffffffffffff8551169273ffffffffffffffffffffffffffffffffffffffff60608c015116928391151681831018911802186fffffffffffffffffffffffffffffffff60408501511662ffffff89169273ffffffffffffffffffffffffffffffffffffffff8316811015915f88125f146150795784620f424003614cd2818a5f03615739565b94841561506857614ce4838583615a31565b955b868110614fad57509173ffffffffffffffffffffffffffffffffffffffff97939160809593978891620f424082145f14614f9e575050865b935b15614f905791614d2f926159f1565b905b60c083015260a0820152015216905285614f585760a08d0151905f8212613251570395614d688d60c06080820151910151906130ad565b5f8112613251578803978813600116611e5c578e8d8f8e5b61ffff8d16614f2b575b6fffffffffffffffffffffffffffffffff60408501511680614f18575b508e73ffffffffffffffffffffffffffffffffffffffff85511673ffffffffffffffffffffffffffffffffffffffff60608601511681145f14614ed757506040840151614e47575b505050508d8d155f14614e3b5760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91015160020b0160020b5b60020b60208201525b969096614b05565b6020015160020b614e2a565b6fffffffffffffffffffffffffffffffff936004614eb09484155f14614ec95760206002820154935b015160020b60020b5f520160205260405f2091600183019081549003905560028201908154900390555460801d9015614ebf575b8260408501511661457c565b1660408201528d8f8e8e614def565b5f03600f0b614ea4565b602060018201549493614e70565b9391505073ffffffffffffffffffffffffffffffffffffffff915051168103614f01575b50614e33565b614f0a9061460a565b60020b60208201525f614efb565b60c084015160801b04909e019d5f614da7565b9c620f42408d61ffff608086015191169060c0860151010204908160c08501510360c0850152019c614d8a565b60808d015160c08e015101905f821261325157019560a08d0151975f8912613251578f908f8f918f9b614f8a91613c00565b9a614d80565b614f9992615ae8565b614d2f565b614fa89189615c1c565b614d1e565b96505050919250938392821586151761505b5773ffffffffffffffffffffffffffffffffffffffff956080938215614ff657614fea878284615cbb565b80978b015f0393614d20565b8787116150345761502f61502a6150226fffffffffffffffffffffffffffffffff84168a60601b614930565b8a85166130ad565b615d4f565b614fea565b61502f61502a6150566fffffffffffffffffffffffffffffffff84168a61583e565b615022565b634f2461b85f526004601cfd5b615073838286615996565b95614ce6565b9294919392841561520d5761508f8183886159f1565b955b8689106150ea576080939273ffffffffffffffffffffffffffffffffffffffff97926150d79280985b156150dc57916150c992615a31565b809580620f42400391615c1c565b614d31565b6150e592615996565b6150c9565b5094509086851583151761505b5784156151e15773ffffffffffffffffffffffffffffffffffffffff881161518e578760601b6fffffffffffffffffffffffffffffffff871680820615159104015b73ffffffffffffffffffffffffffffffffffffffff841693818511156151815773ffffffffffffffffffffffffffffffffffffffff97886150d79360809703165b80986150ba565b634323a5555f526004601cfd5b6fffffffffffffffffffffffffffffffff86166151b9816c010000000000000000000000008b6158f7565b90801561493a576c010000000000000000000000008a09156151395760010180615139575f80fd5b6150d783876152088b73ffffffffffffffffffffffffffffffffffffffff9a608098615c45565b61517a565b615218818784615ae8565b95615091565b6020620d89e89101528d614c0e565b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189101528d614bfb565b5060020b900360020b0260020b614be2565b600160059101918260020b60081d60010b5f520160205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600160ff84161b011990541691821591821592835f14615388576103305760ff847ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618955f03166101e07f804040554300526644320000502061067405302602000010750620017611707760fc7fb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff840260f81c161b60f71c167e1f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405601f85851693831c63d76453e004161a17031660020b9060020b0160020b0260020b5b90614be4565b507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618935060ff81811681031660020b9060020b0160020b0260020b615382565b9750919a509b98939a91969a9792949760208a015160a01b76ffffff0000000000000000000000000000000000000000167fffffffffffffffffff000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8c51169216171782556fffffffffffffffffffffffffffffffff60408a0151168091036154bc575b5082156154b357600201555b151461549b576040615478615481939461385c565b9301510361385c565b6fffffffffffffffffffffffffffffffff169060801b1793565b6154ad9060406154819301510361385c565b9161385c565b60010155615463565b6fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff000000000000000000000000000000006003830154161760038201555f615457565b73ffffffffffffffffffffffffffffffffffffffff9150511673ffffffffffffffffffffffffffffffffffffffff606087015116148f614b0f565b7f9e4d7cc7000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b8d604491604051917f7c9c6e8f00000000000000000000000000000000000000000000000000000000835273ffffffffffffffffffffffffffffffffffffffff1660048301526024820152fd5b6060840173ffffffffffffffffffffffffffffffffffffffff8151168d73ffffffffffffffffffffffffffffffffffffffff1681111561556757505173ffffffffffffffffffffffffffffffffffffffff1673fffd8963efd1fc6a506488495d951d5263988d2681101561553c5750614ab7565b9c509c50509b505050505050505050505f925f929190565b86614a45577f96206246000000000000000000000000000000000000000000000000000000005f5260045ffd5b62ffffff610fff89169116808202620f4240808206151591040191010391614a2b565b508a60d01c62ffffff16614a20565b60028b01546149d3565b610fff8760c41c16926149bd565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393847001000000000000000000000000000000001115610330571461573057700100000000000000000000000000000000910990828211900360801b910360801c1790565b50505060801c90565b818102907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83820990828083109203918083039283620f4240111561033057146157b8577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c2613993620f4240910990828211900360fa1b910360061c170290565b5050620f424091500490565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393846c0100000000000000000000000011156103305714615835576c01000000000000000000000000910990828211900360a01b910360601c1790565b50505060601c90565b908160601b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c0100000000000000000000000084099282808510940393808503948584111561033057146158f0576c0100000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b5091500490565b91818302917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81850993838086109503948086039586851115610330571461598e579082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b505091500490565b6fffffffffffffffffffffffffffffffff6c010000000000000000000000009173ffffffffffffffffffffffffffffffffffffffff80600195169116038060ff1d908101189316926159e881856157c4565b93091515160190565b6fffffffffffffffffffffffffffffffff9073ffffffffffffffffffffffffffffffffffffffff806137269594169116038060ff1d9081011891166157c4565b9073ffffffffffffffffffffffffffffffffffffffff811673ffffffffffffffffffffffffffffffffffffffff831611615ae2575b73ffffffffffffffffffffffffffffffffffffffff8216928315615ad6577bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff615aca948185169403169160601b16615c1c565b90808206151591040190565b62bfc9215f526004601cfd5b90615a66565b73ffffffffffffffffffffffffffffffffffffffff821673ffffffffffffffffffffffffffffffffffffffff821611615b89575b73ffffffffffffffffffffffffffffffffffffffff8116918215615ad657613726937bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff615b84948185169403169160601b166158f7565b614930565b90615b1c565b8015610330577f07060605060205000602030205040001060502050303040105050304000000006f8421084210842108cc6318c6db6d54be826fffffffffffffffffffffffffffffffff1060071b83811c67ffffffffffffffff1060061b1783811c63ffffffff1060051b1783811c61ffff1060041b1783811c60ff1060031b1792831c1c601f161a1790565b929190615c2a8282866158f7565b93821561493a5709615c3857565b9060010190811561033057565b91908115615cb6577bffffffffffffffffffffffffffffffff00000000000000000000000073ffffffffffffffffffffffffffffffffffffffff9160601b169216918282029183838311918404141615615ca9576137269261502a92820391615c1c565b63f5c787f15f526004601cfd5b505090565b90918015615d495773ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffffffffffffffffffff000000000000000000000000819460601b16921680820281615d0b8483614930565b14615d31575b5090615d20615d259284614930565b6130ad565b80820615159104011690565b8301838110615d11579150615d4592615c1c565b1690565b50905090565b9073ffffffffffffffffffffffffffffffffffffffff82169182036132515756fea164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xFD\xD5\x8E\x14a-\x88WP\x80c\x01\xFF\xC9\xA7\x14a,\xC9W\x80c\t[\xCD\xB6\x14a,\x1FW\x80c\x0B\r\x9C\t\x14a+\x93W\x80c\x11\xDA`\xB4\x14a+8W\x80c\x15n)\xF6\x14a*\x88W\x80c\x1E.\xAE\xAF\x14a*NW\x80c#Bf\xD7\x14a'\xAFW\x80c-w\x13\x89\x14a&\xEDW\x80c5\xFDc\x1A\x14a&yW\x80c=\xD4Z\xDB\x14a&\x15W\x80cBj\x84\x93\x14a%\x91W\x80cH\xC8\x94\x91\x14a#\x06W\x80cRu\x96Q\x14a!\xEEW\x80cU\x8Ar\x97\x14a!\x17W\x80cY\x8A\xF9\xE7\x14a \x7FW\x80cZk\xCF\xDA\x14a\x15=W\x80ci\\[\xF5\x14a\x0E\xACW\x80c~\x87\xCE}\x14a\roW\x80c\x80\xF0\xB4L\x14a\x0C\x9FW\x80c\x81a\xB8t\x14a\x0B\xA7W\x80c\x8D\xA5\xCB[\x14a\x0BWW\x80c\x97\xE8\xCDN\x14a\n\xF4W\x80c\x9B\xF6d_\x14a\n\xA7W\x80c\xA5\x84\x11\x94\x14a\nfW\x80c\xB66<\xF2\x14a\t\xD5W\x80c\xDB\xD05\xFF\x14a\t\x7FW\x80c\xF0-\xE3\xB2\x14a\t.W\x80c\xF15\xBA\xAA\x14a\x08\xF4W\x80c\xF2\xFD\xE3\x8B\x14a\x08HW\x80c\xF3\xCD\x91L\x14a\x04\xFFW\x80c\xF5)\x8A\xCA\x14a\x034Wc\xFE\x99\x04\x9A\x14a\x01\x86W_\x80\xFD[4a\x030W`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x01\xBDa-\xF2V[a\x01\xC5a.\x15V[\x90`D5\x91\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x02ys\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`d5\x95\x16\x93\x843\x14\x15\x80a\x03\rW[a\x02\x87W[\x84_R`\x04` R`@_ \x87_R` R`@_ a\x02:\x87\x82Ta0\xA0V[\x90U\x16\x93\x84_R`\x04` R`@_ \x86_R` R`@_ a\x02_\x82\x82Ta0\xADV[\x90U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x90\x91\x82\x91\x82\x01\x90V[\x03\x90\xA4` `@Q`\x01\x81R\xF3[\x84_R`\x05` R`@_ \x823\x16_R` R`@_ \x87_R` R`@_ T\x86\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x02\xDAW[PPa\x02\x19V[a\x02\xE3\x91a0\xA0V[\x85_R`\x05` R`@_ \x833\x16_R` R`@_ \x88_R` R`@_ U_\x86a\x02\xD3V[P\x84_R`\x03` R`@_ \x823\x16_R` R`\xFF`@_ T\x16\x15a\x02\x14V[_\x80\xFD[4a\x030Wa\x03B6a.8V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEDs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80_\x95\x16\x95a\x03\xBBa\x03\xB3\x86a23V[3\x90\x89a2yV[\x16\x923\x84\x14\x15\x80a\x04\xA0W[a\x03\xF2W[\x83\x85R`\x04` R`@\x85 \x86\x86R` R`@\x85 a\x02_\x82\x82Ta0\xA0V[\x03\x90\xA4\0[\x83\x85R`\x05` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`@\x85 \x86\x86R` R`@\x85 T\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x04YW[PPa\x03\xCCV[a\x04b\x91a0\xA0V[\x84\x86R`\x05` R`@\x86 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x87R` R`@\x86 \x87\x87R` R`@\x86 U\x86\x81a\x04RV[P\x83\x85R`\x03` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`\xFF`@\x86 T\x16\x15a\x03\xC7V[\x7FT\xE3\xCA\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Wa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0586a/4V[``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x05o\x82a.\xA9V[`\xA45\x80\x15\x15\x81\x03a\x030W\x82R` \x82\x01\x90`\xC45\x82R`\xE45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`@\x84\x01\x91\x82Ra\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x05\xD0\x906\x90`\x04\x01a0\0V[\x92\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x06\x02a5\xE6V[Q\x15a\x08 W`\xA0\x82 \x92\x83_R`\x06` R`@_ \x90a\x06#\x82a6MV[`\x80\x84\x01\x95\x84\x82\x82\x8A\x8AQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93a\x06N\x94a<\x1BV[\x90\x94\x91\x95``\x88\x01Q`\x02\x0B\x96\x8BQ\x15\x15\x91Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91`@Q\x98a\x06\x85\x8Aa.\xC5V[\x89R` \x89\x01R`@\x88\x01R``\x87\x01Rb\xFF\xFF\xFF\x16`\x80\x86\x01R\x88Q\x15\x15_\x14\x98b\xFF\xFF\xFFa\x07\xA2\x98a\x06\xDBa\x07\x8F\x98` \x9Da\x08\0Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8BQ\x16\x95aIgV[\x94\x92\x96\x82\x91\x92a\x07\xD3W[PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84Q\x16\x93\x8Eo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x83\x01Q\x16\x91\x01Q`\x02\x0B\x90`@Q\x95\x88`\x80\x1D`\x0F\x0B\x87R\x88`\x0F\x0B` \x88\x01R`@\x87\x01R``\x86\x01R`\x80\x85\x01R\x16`\xA0\x83\x01R\x7F@\xE9\xCE\xCB\x9F_\x1F\x1C[\x9C\x97\xDE\xC2\x91{~\xE9.W\xBAUcp\x8D\xAC\xA9M\xD8J\xD7\x11/`\xC03\x93\xA3\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AQ\x16a>XV[\x80\x94\x91\x94a\x07\xAAW[PP\x823\x91a7)V[`@Q\x90\x81R\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xCC\x92Q\x16\x90\x83a7)V[\x84\x80a\x07\x98V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R`\x01\x8FR`@_ \x90\x81T\x01\x90U\x8E\x80a\x06\xE6V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8E\x8C\x01Q\x16\x95aIgV[\x7F\xBE\x8B\x85\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x08\xA0a-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x91a\x08\xC5\x82\x84\x163\x14a0\xBAV[\x16\x91\x82\x91\x16\x17_U3\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\\_R` _\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16`@Q\x90\x81R\xF3[4a\x030Wa\t\x8D6a0.V[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` \x80\x91a\t\xB0V[`@\x81\x86\x03\x01\x90\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\n\x0Ca-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n)a.\x15V[\x91\x16_R`\x03` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\n\xA5a\n\xA0a-\xF2V[a1]V[\0[4a\x030Wa\n\xB56a0.V[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835\\\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` \x80\x91a\n\xD8V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B@a-\xF2V[\x16_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0B\xDEa-\xF2V[a\x0B\xE6a.\x15V[\x90`D5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0CwW` \x92a\x07\xA2\x91\x80a\x0CoWPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x84R`@_ T\x92\x83\x91[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x86R`@_ a\x0Ch\x84\x82Ta0\xA0V[\x90Ua3\x81V[\x92\x83\x91a\x0C<V[\x7FH\xF5\xC3\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\xD6a-\xF2V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W3_\x90\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16` R`@\x90 \\a\r,`$5a23V[\x90\x81`\x0F\x0B\x03a\rGWa\n\xA5\x913\x91_\x03`\x0F\x0B\x90a2yV[\x7F\xBD\xA7:\xBF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\r\xA76a/4V[a\r\xAFa/\"V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0CwWa\x03\xE9a\x0F\xFF\x83\x16\x10b>\x90\0b\xFF\xF0\0\x84\x16\x10\x16\x15a\x0E{W` `\xA0\x7F\xE9\xC4%\x93\xE7\x1F\x84@;\x845,\xD1h\xD6\x93\xE2\xC9\xFC\xD1\xFD\xBC\xC3\xFE\xB2\x1D\x92\xB4>f\x96\xF9\x92 \x92\x83_R`\x06\x82R`@_ a\x0E%\x81a6MV[\x80Ty\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`\xB8\x1B\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ub\xFF\xFF\xFF`@Q\x91\x16\x81R\xA2\0[b\xFF\xFF\xFF\x82\x7F\xA7\xAB\xE2\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[4a\x030W`\xE0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0E\xE46a/4V[`\xA45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x83\x03a\x030W`\xC45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x0F&\x906\x90`\x04\x01a0\0V[\x90a\x0F/a5\xE6V[``\x84\x01\x93\x84Q`\x02\x0Ba\x7F\xFF\x81\x13a\x15\x12WP\x84Q`\x02\x0B`\x01\x81\x12a\x14\xE7WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x92` \x82\x01\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x80\x82\x10\x15a\x14\xB0WPP`\x80\x82\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x95`@\x84\x01\x96a\x0F\xC3b\xFF\xFF\xFF\x89Q\x16\x82a:\x8EV[\x15a\x14\x85WPa\x0F\xD8b\xFF\xFF\xFF\x88Q\x16a;LV[\x91\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x13\xC2W[PP`\xA0\x85 \x95_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16\x80a\x12~W[P\x87_R`\x06` R`@_ \x90\x81Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12VWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xDDFngN\xA5W\xF5b\x95\xE2\xD0!\x8A\x12^\xA4\xB4\xF0\xF6\xF30{\x95\xF8^a\x10\x83\x8Dd8\x98`\xA0\x98` \x9F\x98\x83\x96b\xFF\xFF\xFF\x96\x85\x96a\x10\xBA|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9DaF\nV[\x9C\x8D\x94`\xD0\x1B\x16\x90y\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Fv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8F\x91\x88\x90\x1B\x16\x17\x91`\xB8\x1B\x16\x17\x17\x90U\x88Q\x90\x8A\x86\x83\x16\x92\x833\x03a\x11TW[PPPPPPQ\x16\x99Q\x16\x99Q\x16\x99Q`\x02\x0B\x91Q\x16\x90`@Q\x99\x8AR\x8A\x8A\x01R`@\x89\x01R``\x88\x01R`\x02\x0B\x95\x86`\x80\x82\x01R\xA4`@Q\x90\x81R\xF3[a\x10\0\x16a\x11cW[\x81a\x11\x16V[a\x12\x1Aa\x12F\x92a\x12K\x96`@Q\x96` \x94\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\x96\x87\x01R3`$\x87\x01Ra\x11\xF8`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xE4\x86\x01R`\x02\x0Ba\x01\x04\x85\x01Ra\x01 a\x01$\x85\x01Ra\x01D\x84\x01\x91a1\x1FV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x84R\x83a.\xE1V[a?\xFCV[P\x8F\x88\x81\x80\x8Aa\x11]V[\x7Fy\x83\xC0Q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90PZ\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x92\x10a\x13\x9AW` \x91_\x91\x82`@Q\x91\x85\x83\x01\x92\x7FU;\xFC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84Ra\x133\x8D`$\x83\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xA4\x81Ra\x13B`\xC4\x82a.\xE1V[Q\x93\xF1_Q\x90` =\x14\x16\x80a\x13\x8CW[\x80a\x13qW[\x15a\x13jWb\xFF\xFF\xFF\x16[\x8Ca\x10\"V[P_a\x13dV[Pa\x03\xE9a\x0F\xFF\x82\x16\x10b>\x90\0b\xFF\xF0\0\x83\x16\x10\x16a\x13YV[Pb\xFF\xFF\xFF\x81\x16\x81\x14a\x13SV[\x7F\x1E\xE4\x97\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a \0\x16a\x13\xD1W[\x80a\x0F\xFBV[a\x14~\x90`@Q\x90\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01R3`$\x83\x01Ra\x14\\`D\x83\x01\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x84`\xE4\x83\x01Ra\x01\0a\x01\x04\x83\x01Ra\x12F\x82a\x12\x1Aa\x01$\x82\x01\x8A\x8Da1\x1FV[P\x8Aa\x13\xCBV[\x7F\xE6Z\xF6\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[`D\x92P`@Q\x91\x7Fnl\x980\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x04\x83\x01R`$\x82\x01R\xFD[\x7F\xE9\xE9\x05\x88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xB7\0$\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[4a\x030Wa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x15v6a/4V[`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x15\xAD\x82a.\x8DV[`\xA45\x80`\x02\x0B\x81\x03a\x030W\x82R`\xC45\x80`\x02\x0B\x81\x03a\x030W` \x83\x01R`\xE45`@\x83\x01Ra\x01\x045``\x83\x01Ra\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x16\0\x906\x90`\x04\x01a0\0V[\x90\x92\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x161a5\xE6V[`\xA0\x83 \x93\x84_R`\x06` R`@_ `\x80Ra\x16P`\x80Qa6MV[`\x80\x84\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x1F\xA6W[PP\x81Q`\x02\x0B\x92` \x83\x01Q`\x02\x0B\x91a\x16\x93`@\x85\x01Qa8\\V[\x93``\x87\x01Q`\x02\x0B\x97``\x82\x01Q`@Q\x99`\xC0\x8B\x01\x8B\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@R3\x8BR\x88` \x8C\x01R\x86`@\x8C\x01R\x87`\x0F\x0B``\x8C\x01R`\x80\x8B\x01R`\xA0\x8A\x01R_\x91\x85\x88\x12\x15a\x1FBW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x88\x12a\x1F\x16Wb\r\x89\xE8\x86\x13a\x1E\xEAW`@Q\x92a\x17*\x84a.\x8DV[_\x84R_` \x85\x01R_`@\x85\x01R_``\x85\x01R\x87`\x0F\x0Ba\x1C\x13W[`\x04`\x80Q\x01\x97\x89`\x02\x0B_R\x88` R`@_ \x98\x88`\x02\x0B_R` R`@_ `\x80QT`\xA0\x1C`\x02\x0B\x8B\x81\x12_\x14a\x1B\xBDWP`\x02\x80`\x01\x8C\x01T`\x01\x84\x01T\x90\x03\x9B\x01T\x91\x01T\x90\x03\x9B[`\xA0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82Q\x16\x91\x01Q\x90`@Q\x91`&\x83\x01R\x89`\x06\x83\x01R\x8B`\x03\x83\x01R\x81R_`:`\x0C\x83\x01 \x91\x81`@\x82\x01R\x81` \x82\x01RR_R`\x06`\x80Q\x01` R`@_ \x97o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89T\x16\x99\x82`\x0F\x0B\x15_\x14a\x1B`W\x8A\x15a\x1B8Wa\x18]a\x18W`@\x9F\x9Ba\x19<\x9Ca\x19N\x9E[`\x01\x83\x01\x95a\x18O`\x02a\x18C\x84\x8AT\x85\x03aV\xB7V[\x95\x01\x92\x83T\x85\x03aV\xB7V[\x96UUa23V[\x91a23V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x9A\x8B\x96_\x84`\x0F\x0B\x12a\x1A\xCAW[P\x82`\x0F\x0Ba\x19\x86W[PPPa\x18\xB2a\x18\xA3\x85`\x80\x1D\x83`\x80\x1D\x01a8\\V[\x91\x85`\x0F\x0B\x90`\x0F\x0B\x01a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x91\x81Q`\x02\x0B\x90` \x83\x01Q`\x02\x0B\x8C\x84\x01Q``\x85\x01Q\x91\x8EQ\x94\x85R` \x85\x01R\x8D\x84\x01R``\x83\x01R\x7F\xF2\x08\xF4\x91'\x82\xFD%\xC7\xF1\x14\xCA7#\xA2\xD5\xDDo;\xCC:\xC8\xDBZ\xF6;\xAA\x85\xF7\x11\xD5\xEC`\x803\x93\xA3\x88s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x16a92V[\x80\x94\x91\x94a\x19ZW[P\x833\x91a7)V[\x82Q\x91\x82R` \x82\x01R\xF3[a\x19\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x84\x01Q\x16\x90\x83a7)V[\x85a\x19EV[`\x80QT\x92\x93P\x90\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90`\xA0\x1C`\x02\x0B\x82\x81\x12\x15a\x19\xECWPP\x90a\x19\xE0\x92a\x19\xD5a\x19\xCBa\x19\xDB\x94aAfV[\x91`\x0F\x0B\x92aAfV[\x90aE5V[a8\\V[`\x80\x1B[\x8B\x80\x80a\x18\x8CV[\x92\x80\x91\x93\x12_\x14a\x1A\x97Wa\x1A+\x91a\x1A\x18a\x19\xDBa\x19\xDB\x93a\x1A\x12\x88`\x0F\x0B\x91aAfV[\x87aE5V[\x93a\x1A&\x86`\x0F\x0B\x92aAfV[aD\xD8V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1Aj`\x03`\x80Q\x01\x92`\x0F\x0B\x82\x84T\x16aE|V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x19\xE4V[\x90a\x19\xDB\x92P\x92a\x1A\xADa\x19\xCBa\x1A\xB3\x95aAfV[\x90aD\xD8V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\xE4V[\x80\x8F\x91Qa\x1B\x0CW[\x01Qa\x1A\xE0W[\x8Ea\x18\x82V[a\x1B\x07\x82`\x80Q`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\xDAV[a\x1B3\x83`\x80Q`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\xD3V[\x7F\xAE\xFE\xB9$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x18]a\x18W`@\x9F\x9Ba\x19<\x9Ca\x19N\x9Eo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1B\x90\x89`\x0F\x0B\x83aE|V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84T\x16\x17\x83Ua\x18,V[\x90\x99\x90\x89\x13a\x1B\xE3W`\x02\x80`\x01\x8C\x01T`\x01\x84\x01T\x90\x03\x9B\x01T\x91\x01T\x90\x03\x9Ba\x17\x98V[\x98`\x02`\x01`\x80Q\x01T`\x01\x8C\x01T\x90\x03`\x01\x83\x01T\x90\x03\x9A\x81\x80`\x80Q\x01T\x91\x01T\x90\x03\x91\x01T\x90\x03\x9Ba\x17\x98V[`\x04`\x80Q\x01\x89`\x02\x0B_R\x80` R\x89\x89`@_ a\x1Cl\x81To\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1CO\x81\x83\x16\x95`\x0F\x0B\x86aE|V[\x16\x93\x15\x94\x85\x85\x15\x14\x15\x95a\x1E\xB6W[P\x8D`\x0F\x0B\x90`\x80\x1Da>\x11V[`\x80\x1B\x82\x17\x90U` \x87\x01R\x85R\x87`\x02\x0B_R` R`@_ \x80T\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16a\x1C\xAA\x8B`\x0F\x0B\x82aE|V[\x90\x15\x92\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15\x14\x15\x93a\x1E\x89W[\x8B`\x0F\x0B\x90`\x80\x1D`\x0F\x0B\x03\x91o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x12\x17a\x1E\\W\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93P`\x80\x1B\x83\x83\x16\x17\x90U\x16``\x86\x01R`@\x85\x01R_\x88`\x0F\x0B\x12\x15a\x1D\x8FW[\x83Qa\x1DsW[`@\x84\x01Q\x15a\x17HWa\x1Dn`\x80\x8C\x01Q`\x02\x0B\x88`\x05`\x80Q\x01aA\x1AV[a\x17HV[a\x1D\x8A`\x80\x8C\x01Q`\x02\x0B\x8A`\x05`\x80Q\x01aA\x1AV[a\x1DMV[`\x80\x8B\x01Q`\x02\x0Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01\x81` \x88\x01Q\x16\x92\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x05\x90b\r\x89\xE8\x05\x03\x01\x81\x04\x16\x80\x91\x11a\x1E0Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x86\x01Q\x16\x11\x15a\x1DFW\x86\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x89\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[`\x80QT`\xA0\x1C`\x02\x0B\x8B\x13a\x1C\xCAW`\x01`\x80Q\x01T`\x01\x84\x01U`\x02`\x80Q\x01T`\x02\x84\x01Ua\x1C\xCAV[`\x80QT`\xA0\x1C`\x02\x0B\x12\x15a\x1E\xCDW[\x8Ea\x1C^V[`\x01`\x80Q\x01T`\x01\x84\x01U`\x02`\x80Q\x01T`\x02\x84\x01Ua\x1E\xC7V[\x85\x7F\x1A\xD7w\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xD5\xE2\xF7\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[`D\x88\x87`@Q\x91\x7F\xC4C>\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x04\x83\x01R`$\x82\x01R\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_`@\x85\x01Q\x13\x80\x80\x91a rW[\x15a \x07WPP`@Q\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x1F\xFE\x91a\x12F\x82a\x12\x1A\x88\x87\x89\x8C3`$\x87\x01a7\xA2V[P[\x85\x80a\x16uV[\x15\x90\x81a dW[Pa \x1BW[Pa \0V[`@Q\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra ]\x91a\x12F\x82a\x12\x1A\x88\x87\x89\x8C3`$\x87\x01a7\xA2V[P\x85a \x15V[a\x02\0\x91P\x16\x15\x15\x87a \x0FV[Pa\x08\0\x82\x16\x15\x15a\x1F\xB5V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa \xB6a-\xF2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa \xD3a.\x15V[\x91\x16_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ `D5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa!Na-\xF2V[`$5\x90\x81\x15\x15\x80\x92\x03a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x903_R`\x03` R`@_ \x82\x82\x16_R` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16`\xFF\x85\x16\x17\x90U`@Q\x92\x83R\x16\x90\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` 3\x92\xA3` `@Q`\x01\x81R\xF3[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\"&6a/4V[a\".a/\"V[\x90b\x80\0\0b\xFF\xFF\xFF`@\x83\x01Q\x16\x14\x80\x15\x90a\"\xE2W[a\"\xBAW`\xA0\x90a\"V\x83a7eV[ _R`\x06` R`@_ \x90a\"l\x82a6MV[\x81T\x7F\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xD0\x91\x90\x91\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90U\0[\x7F0\xD2\x16A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x163\x14\x15a\"FV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa#U\x906\x90`\x04\x01a0\0V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\a%iWa#\xE1\x91_\x91`\x01\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]`@Q\x93\x84\x92\x83\x92\x7F\x91\xDDsF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R` `\x04\x85\x01R`$\x84\x01\x91a1\x1FV[\x03\x81\x833Z\xF1\x90\x81\x15a%^W_\x91a$\xB6W[P\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\a$\x8EW`@` \x91_\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[\x7FR\x12\xCB\xA1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P=\x80_\x83>a$\xC7\x81\x83a.\xE1V[\x81\x01\x90` \x81\x83\x03\x12a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x030W\x01\x81`\x1F\x82\x01\x12\x15a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1FyW`@Q\x92a%:` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x86\x01\x16\x01\x85a.\xE1V[\x82\x84R` \x83\x83\x01\x01\x11a\x030W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x81a#\xF5V[`@Q=_\x82>=\x90\xFD[\x7FP\x90\xD6\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa%\xB46a.8V[\x91\x92\x90\x923_R`\x05` R`@_ \x82\x82\x16_R` R`@_ \x84_R` R\x82`@_ U`@Q\x92\x83R\x16\x90\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` 3\x92\xA4` `@Q`\x01\x81R\xF3[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa&Ga-\xF2V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\x07\xA2` \x91a5\x04V[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`$5`\x045`@Q\x91`@\x83` \x81R\x82` \x82\x01R\x01\x90`\x05\x1B\x83\x01\x91`\x01` `@\x85\x01\x93[\x83T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\t\xCCWP` `\x01\x91a&\xD1V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x030Wa'_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x163\x14a0\xBAV[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U\x7F\xB4\xBD\x8E\xF5=\xF6\x90\xB9\x94=3\x18\x99`\x06\xDB\xB8*%\xF5G\x19\xD8\xC8\x03[Qj*[\x8A\xCC_\x80\xA2\0[4a\x030Wa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa'\xE86a/4V[`\xC45\x90`\xA45`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa(\x0F\x906\x90`\x04\x01a0\0V[\x91\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa(Aa5\xE6V[`\xA0\x84 \x94\x85_R`\x06` R`@_ \x94a(\\\x86a6MV[`\x80\x81\x01\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a)\xF6W[PPo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x97\x88\x15a)\xCEW` \x98a(\xAE\x87a23V[_\x03a(\xB9\x87a23V[_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x98\x87a)\xBAW[\x86a)\xA5W[PPa(\xEC3\x89\x85a7)V[`@Q\x90\x86\x82R\x85\x8A\x83\x01R\x7F)\xEF\x05\xCA\xAF\xF9@K|\xB6\xD1\xC0\xE9\xBB\xAE\x9E\xAAz\xB2T\x1F\xEB\xA1\xA9\xC4$\x85\x94\xC0\x81V\xCB`@3\x93\xA3Q\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x843\x03a)JW[\x88\x88`@Q\x90\x81R\xF3[`\x10\x16a)XW[\x80a)@V[a)\x99\x95a\x12F\x93a\x12\x1A\x92`@Q\x97\x88\x95\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8D\x88\x01R3`$\x88\x01a6\x93V[P\x82\x80\x80\x80\x80\x80a)RV[`\x02\x01\x90\x86`\x80\x1B\x04\x81T\x01\x90U\x89\x80a(\xDFV[`\x01\x81\x01\x82\x89`\x80\x1B\x04\x81T\x01\x90Ua(\xD9V[\x7F\xA7O\x97\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x16a*\x04W[\x80a(\x82V[`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra*G\x91a\x12F\x82a\x12\x1A\x8B\x89\x8B\x8D\x8B3`$\x88\x01a6\x93V[P\x88a)\xFEV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045T_R` _\xF3[4a\x030Wa*\x966a.8V[\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEDs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80_\x94\x16\x95a+\x15a+\x08\x87a23V[\x86\x03`\x0F\x0B3\x90\x89a2yV[\x16\x93\x84\x84R`\x04` R`@\x84 \x86\x85R` R`@\x84 a\x02_\x82\x82Ta0\xADV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7W` a\x07\xA23a5\x04V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa+\xCAa-\xF2V[a+\xD2a.\x15V[`D5\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD7Wa\n\xA5\x92a,\x1Aa,\r\x84a23V[_\x03`\x0F\x0B3\x90\x83a2yV[a3\x81V[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa,B6a.8V[\x91\x92\x90\x923_R`\x04` R`@_ \x84_R` R`@_ a,g\x84\x82Ta0\xA0V[\x90U\x16\x90\x81_R`\x04` R`@_ \x83_R` R`@_ a,\x8C\x82\x82Ta0\xADV[\x90U`@\x80Q3\x80\x82R` \x82\x01\x93\x90\x93R\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\x91\x81\x90\x81\x01a\x02yV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x030W\x80\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a-^W[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x0Fc/\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a-SV[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa-\xD7a-\xF2V[\x16_R`\x04\x82R`@_ `$5_R\x82R`@_ T\x81R\xF3[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC``\x91\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x90`$5\x90`D5\x90V[`\x80\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[``\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[`\xA0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1FyW`@RV[`\xA45\x90b\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC`\xA0\x91\x01\x12a\x030W`@Q\x90a/k\x82a.\xC5V[\x81`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x030W`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x030W``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`\x80\x01RV[\x91\x81`\x1F\x84\x01\x12\x15a\x030W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x030W` \x83\x81\x86\x01\x95\x01\x01\x11a\x030WV[\x90` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030W\x82`#\x82\x01\x12\x15a\x030W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x030W`$\x84`\x05\x1B\x83\x01\x01\x11a\x030W`$\x01\x91\x90V[\x91\x90\x82\x03\x91\x82\x11a\x1E\\WV[\x91\x90\x82\x01\x80\x92\x11a\x1E\\WV[\x15a0\xC1WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FUNAUTHORIZED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[`\x1F\x82` \x94\x93\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x93\x81\x86R\x86\x86\x017_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9\\\x16a2\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x15a2\x07Wa1\xC0\x90a;iV[\x90\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9]\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95]V[PPV[\x7F\x99l\xAFe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a2QW`\x0F\x0B\x90V[\x7F\x93\xDA\xFD\xF1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x90`\x0F\x0B\x91\x82\x15a3|Wa2\xAF\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x92\x16_R\x16` R`@_ \x90V[a2\xBB\x81\\\x92\x83a<\0V[\x80\x91]a3,WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B][V[\x15a33WV[`\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B]V[PPPV[\x90\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81a4\x1FWPP_\x80\x80\x80\x93\x85Z\xF1\x15a3\xB3WPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=`@Q\x93\x7F\x85I\xDBY\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[` _`D\x81\x94\x96\x82`@\x95s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x98\x87Q\x99\x8A\x94\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R\x16`\x04\x85\x01R`$\x84\x01RZ\xF1=\x15`\x1F=\x11`\x01\x85Q\x14\x16\x17\x16\x92\x82\x81R\x82` \x82\x01R\x01R\x15a4\x98WPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=`@Q\x93\x7F\xB1,_\x9C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9\\\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a5YWa3*\x904\x93[a5S\x85a23V[\x90a2yV[4a5\xBEWa3*\x90a5\x95\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95\\a5\x90\x86a;iV[a0\xA0V[\x93_\x7F'\xE0\x98\xC5\x05\xD4N\xC3W@\x04\xBC\xA0R\xAA\xBFv\xBD5\0L\x18 \x99\xD8\xC5u\xFB#\x85\x93\xB9]a5JV[\x7F\xB0\xEC\x84\x9E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a6%WV[\x7F\r\x89C\x8E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a6kWV[\x7FHj\xA3\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x92a7\x0Ea\x01 \x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa7&\x99\x97\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xC0\x83\x01R`\xE0\x82\x01R\x81a\x01\0\x82\x01R\x01\x91a1\x1FV[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` a3*\x94\x93a7X\x85\x84\x83Q\x16\x86`\x80\x1D\x90a2yV[\x01Q\x16\x90`\x0F\x0B\x90a2yV[b\xFF\xFF\xFF\x16b\x0FB@\x81\x11a7wWPV[\x7F\x14\0!\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90a7&\x95\x93a8\x1Fa\x01`\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa8N\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x85\x01R` \x82\x01Q\x90\x0B`\xE0\x84\x01R`@\x81\x01Qa\x01\0\x84\x01R``\x01Qa\x01 \x83\x01RV[\x81a\x01@\x82\x01R\x01\x91a1\x1FV[\x90\x81`\x0F\x0B\x91\x82\x03a2QWV[\x92a9\x18\x90a8\xE9a7&\x99\x97\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x01\xA0\x98\x95\x16\x87R` \x87\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x87\x01R` \x82\x01Q\x90\x0B`\xE0\x86\x01R`@\x81\x01Qa\x01\0\x86\x01R``\x01Qa\x01 \x85\x01RV[a\x01@\x83\x01Ra\x01`\x82\x01R\x81a\x01\x80\x82\x01R\x01\x91a1\x1FV[\x93\x95\x90\x91\x92\x96\x94_\x96s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x163\x14a:\x83W\x88_`@\x87\x01Q\x13_\x14a:\x12Wa\x04\0\x87\x16a9yW[PPPPPPPV[a:\x05\x97\x99\x98P\x92a9\xFE\x96\x95\x94\x92a9\xC6\x92a9\xF2\x95`@Q\x97\x88\x96\x7F\x9F\x06>\xFC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01a8jV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a.\xE1V[`\x02\x82\x16\x15\x15\x91aE\xADV[\x80\x92aE\xCDV[\x91_\x80\x80\x80\x80\x80\x80a9pV[\x95\x94\x93\x92\x91\x90a\x01\0\x86\x16a:*WPPPPPPPV[a:\x05\x97\x99P\x86\x98P\x91a9\xC6\x91a:w\x94\x93a9\xFE\x98`@Q\x97\x88\x96\x7Fl+\xBE~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01a8jV[`\x01\x82\x16\x15\x15\x91aE\xADV[P_\x96PPPPPPV[`\x80\x81\x16\x15\x80a;@W[a;\x16W`@\x81\x16\x15\x80a;4W[a;\x16Wa\x04\0\x81\x16\x15\x80a;(W[a;\x16Wa\x01\0\x81\x16\x15\x80a;\x1CW[a;\x16Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a:\xF6WPb\xFF\xFF\xFF\x16b\x80\0\0\x14\x15\x90V[a?\xFF\x16\x15\x90\x81\x15\x91a;\x07WP\x90V[b\x80\0\0\x91Pb\xFF\xFF\xFF\x16\x14\x90V[PP_\x90V[P`\x01\x81\x16\x15\x15a:\xC8V[P`\x02\x81\x16\x15\x15a:\xB8V[P`\x04\x81\x16\x15\x15a:\xA8V[P`\x08\x81\x16\x15\x15a:\x99V[b\x80\0\0b\xFF\xFF\xFF\x82\x16\x14a;dWa7&\x81a7eV[P_\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a;\x89WPG\x90V[` `$\x91`@Q\x92\x83\x80\x92\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R0`\x04\x83\x01RZ\xFA\x90\x81\x15a%^W_\x91a;\xD1WP\x90V[\x90P` \x81=` \x11a;\xF8W[\x81a;\xEC` \x93\x83a.\xE1V[\x81\x01\x03\x12a\x030WQ\x90V[=\x91Pa;\xDFV[\x91\x90\x91_\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x1E\\WV[` \x83\x01Q\x95_\x95\x86\x95\x91\x94\x913s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x14a>\x04W`\x80\x84\x16a<UW[PPPPPV[a==\x92a9\xC6a=7\x92a=#\x94`@Q\x95\x86\x94\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01Ra<\xED`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q\x15\x15`\xE4\x87\x01R` \x81\x01Qa\x01\x04\x87\x01R`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01$\x86\x01RV[a\x01@a\x01D\x85\x01Ra\x01d\x84\x01\x91a1\x1FV[\x82a?\xFCV[\x91``\x83Q\x03a=\xDCW`@\x01Qb\xFF\xFF\xFF\x16b\x80\0\0\x14a=\xD0W[`\x08\x16a=kW[\x80\x80\x80\x80a<NV[`@\x01Q\x92P`\x80\x83\x90\x1D`\x0F\x0B\x80\x15a=bWa=\x8C\x90_\x86\x12\x95a<\0V[\x93\x15a=\xC8W_\x84\x13[a=\xA0W_a=bV[\x7F\xFA\x0Bq\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x84\x12a=\x96V[``\x82\x01Q\x93Pa=ZV[\x7F\x1E\x04\x8E\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P_\x96P\x86\x95PPPPPV[\x90`\x0F\x0B\x90`\x0F\x0B\x01\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x12o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x17a\x1E\\WV[\x91\x96\x95\x93\x94\x92\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x163\x14a?\xEFW\x84`\x80\x1D\x94`\x0F\x0B\x93\x88`@\x85\x16a?\x17W[PPPPP_\x94\x81`\x0F\x0B\x15\x80\x15\x90a?\x0BW[a>\xAFW[PPP\x91\x90V[a>\xE6\x93\x95P_` \x82\x01Q\x12\x90Q\x15\x15\x14_\x14a>\xEEWo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17[\x80\x93aE\xCDV[_\x80\x80a>\xA8V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17a>\xDFV[P\x82`\x0F\x0B\x15\x15a>\xA3V[a?\xD3a?\xDF\x94a9\xC6a\x19\xDB\x95a?\xE5\x99\x98\x95a?\xB8a<\xED\x96`@Q\x97\x88\x96\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x8Ca\x01D\x85\x01Ra\x01`a\x01d\x85\x01Ra\x01\x84\x84\x01\x91a1\x1FV[`\x04\x82\x16\x15\x15\x91aE\xADV[\x90a>\x11V[_\x80\x80\x80\x88a>\x8FV[PPPPP\x90\x91P\x90_\x90V[\x91\x90\x91_\x80` \x85Q\x95\x01\x94\x85\x82\x85Z\xF1\x15a@\x98WP`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?=\x01\x16\x83\x01`@R=\x83R=\x90` \x84\x01\x91_\x83>` \x84Q\x10\x91\x82\x15a@dW[PPa=\xDCWV[Q\x90Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x91\x16\x14\x15\x90P_\x80a@\\V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F=s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x94\x7F1\x9DT\xC3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R\x16`\x04\x85\x01R`@`$\x85\x01R\x80`D\x85\x01R\x80_`d\x86\x01>\x01\x16`d\x01\x90\xFD[\x91\x90`\x02\x0B\x90`\x02\x0B\x90\x81\x81\x07aAHW\x05\x90\x81`\x08\x1D_R` R`\x01`\xFF`@_ \x92\x16\x1B\x81T\x18\x90UV[`\x1C\x90`D\x92`@Q\x91c\xD4\xD8\xF3\xE6\x83R` \x83\x01R`@\x82\x01R\x01\xFD[`\x02\x0B\x90\x81`\xFF\x1D\x82\x81\x01\x18b\r\x89\xE8\x81\x11aD\xACWc\xFF\xFF\xFF\xFF\x91\x92`\x01\x82\x16p\x01\xFF\xFC\xB93\xBDo\xAD7\xAA-\x16-\x1AY@\x01\x02p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\x91`\x02\x81\x16aD\x90W[`\x04\x81\x16aDtW[`\x08\x81\x16aDXW[`\x10\x81\x16aD<W[` \x81\x16aD W[`@\x81\x16aD\x04W[`\x80\x81\x16aC\xE8W[a\x01\0\x81\x16aC\xCCW[a\x02\0\x81\x16aC\xB0W[a\x04\0\x81\x16aC\x94W[a\x08\0\x81\x16aCxW[a\x10\0\x81\x16aC\\W[a \0\x81\x16aC@W[a@\0\x81\x16aC$W[a\x80\0\x81\x16aC\x08W[b\x01\0\0\x81\x16aB\xECW[b\x02\0\0\x81\x16aB\xD1W[b\x04\0\0\x81\x16aB\xB6W[b\x08\0\0\x16aB\x9DW[_\x12aBvW[\x01` \x1C\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04aBoV[k\x04\x8A\x17\x03\x91\xF7\xDCBDN\x8F\xA2\x90\x91\x02`\x80\x1C\x90aBhV[m\"\x16\xE5\x84\xF5\xFA\x1E\xA9&\x04\x1B\xED\xFE\x98\x90\x92\x02`\x80\x1C\x91aB^V[\x91n]j\xF8\xDE\xDB\x81\x19f\x99\xC3)\"^\xE6\x04\x02`\x80\x1C\x91aBSV[\x91o\t\xAAP\x8B[z\x84\xE1\xC6w\xDET\xF3\xE9\x9B\xC9\x02`\x80\x1C\x91aBHV[\x91o1\xBE\x13_\x97\xD0\x8F\xD9\x81#\x15\x05T/\xCF\xA6\x02`\x80\x1C\x91aB=V[\x91op\xD8i\xA1V\xD2\xA1\xB8\x90\xBB=\xF6+\xAF2\xF7\x02`\x80\x1C\x91aB3V[\x91o\xA9\xF7FF-\x87\x0F\xDF\x8Ae\xDC\x1F\x90\xE0a\xE5\x02`\x80\x1C\x91aB)V[\x91o\xD0\x97\xF3\xBD\xFD \"\xB8\x84Z\xD8\xF7\x92\xAAX%\x02`\x80\x1C\x91aB\x1FV[\x91o\xE7\x15\x94u\xA2\xC2\x9BtC\xB2\x9C\x7F\xA6\xE8\x89\xD9\x02`\x80\x1C\x91aB\x15V[\x91o\xF39+\x08\"\xB7\0\x05\x94\x0Cz9\x8EKp\xF3\x02`\x80\x1C\x91aB\x0BV[\x91o\xF9\x87\xA7%:\xC4\x13\x17o+\x07L\xF7\x81^T\x02`\x80\x1C\x91aB\x01V[\x91o\xFC\xBE\x86\xC7\x90\n\x88\xAE\xDC\xFF\xC8;G\x9A\xA3\xA4\x02`\x80\x1C\x91aA\xF7V[\x91o\xFE]\xEE\x04j\x99\xA2\xA8\x11\xC4a\xF1\x96\x9C0S\x02`\x80\x1C\x91aA\xEDV[\x91o\xFF.\xA1df\xC9j8C\xECx\xB3&\xB5(a\x02`\x80\x1C\x91aA\xE4V[\x91o\xFF\x97;A\xFA\x98\xC0\x81G.h\x96\xDF\xB2T\xC0\x02`\x80\x1C\x91aA\xDBV[\x91o\xFF\xCB\x98C\xD6\x0FaY\xC9\xDBX\x83\\\x92fD\x02`\x80\x1C\x91aA\xD2V[\x91o\xFF\xE5\xCA\xCA~\x10\xE4\xE6\x1C6$\xEA\xA0\x94\x1C\xD0\x02`\x80\x1C\x91aA\xC9V[\x91o\xFF\xF2\xE5\x0F_ei2\xEF\x125|\xF3\xC7\xFD\xCC\x02`\x80\x1C\x91aA\xC0V[\x91o\xFF\xF9rr7=A2Y\xA4i\x90X\x0E!:\x02`\x80\x1C\x91aA\xB7V[\x82\x7F\x8B\x862z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90_\x83`\x0F\x0B\x12_\x14aE\rWaE\x03\x92_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aY\xF1V[_\x81\x12a2QW\x90V[aE)\x92o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aY\x96V[_\x81\x12a2QW_\x03\x90V[\x90_\x83`\x0F\x0B\x12_\x14aE`WaE\x03\x92_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ\xE8V[aE)\x92o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ1V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90`\x0F\x0B\x91\x16\x01\x90\x81`\x80\x1CaE\xA0WV[c\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x90aE\xB7\x91a?\xFCV[\x90\x15a;dW`@\x81Q\x03a=\xDCW`@\x01Q\x90V[aE\xF0\x90aE\xE2\x83`\x80\x1D\x82`\x80\x1D\x03a8\\V[\x92`\x0F\x0B\x90`\x0F\x0B\x03a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90V[s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DQc\x96\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFD\x89]\x83\x01\x16\x11aH\xEEWw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x81` \x1B\x16\x80`\xFFaF\x87\x83a[\x8FV[\x16\x91`\x80\x83\x10aH\xE2WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x82\x01\x1C[\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x90\x81`\x7F\x1C\x82`\xFF\x1C\x1C\x80\x02\x92\x83`\x7F\x1C\x84`\xFF\x1C\x1C\x80\x02\x94\x85`\x7F\x1C\x86`\xFF\x1C\x1C\x80\x02\x96\x87`\x7F\x1C\x88`\xFF\x1C\x1C\x80\x02\x98\x89`\x7F\x1C\x8A`\xFF\x1C\x1C\x80\x02\x9A\x8B`\x7F\x1C\x8C`\xFF\x1C\x1C\x80\x02\x9C\x8D\x80`\x7F\x1C\x90`\xFF\x1C\x1C\x80\x02`\xCD\x1Cf\x04\0\0\0\0\0\0\x16\x9D`\xCC\x1Cf\x08\0\0\0\0\0\0\x16\x9C`\xCB\x1Cf\x10\0\0\0\0\0\0\x16\x9B`\xCA\x1Cf \0\0\0\0\0\0\x16\x9A`\xC9\x1Cf@\0\0\0\0\0\0\x16\x99`\xC8\x1Cf\x80\0\0\0\0\0\0\x16\x98`\xC7\x1Cg\x01\0\0\0\0\0\0\0\x16\x97`\xC6\x1Cg\x02\0\0\0\0\0\0\0\x16\x96`\xC5\x1Cg\x04\0\0\0\0\0\0\0\x16\x95`\xC4\x1Cg\x08\0\0\0\0\0\0\0\x16\x94`\xC3\x1Cg\x10\0\0\0\0\0\0\0\x16\x93`\xC2\x1Cg \0\0\0\0\0\0\0\x16\x92`\xC1\x1Cg@\0\0\0\0\0\0\0\x16\x91`\xC0\x1Cg\x80\0\0\0\0\0\0\0\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x01`@\x1B\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17i6'\xA3\x01\xD7\x10UwL\x85\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFDp\x9B~T\x80\xFB\xA5\xA5\x0F\xED^b\xFF\xC5V\x81\x01`\x80\x1D`\x02\x0B\x90o\xDB-\xF0\x9E\x81\x95\x9A\x81E^&\x07\x99\xA0c/\x01`\x80\x1D`\x02\x0B\x91\x82\x82\x14_\x14aH\x9FWP\x90P\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaH\xD3\x84aAfV[\x16\x11aH\xDDWP\x90V[\x90P\x90V[\x90P\x81`\x7F\x03\x1BaF\xB7V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7FaHu$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[\x81\x15aI:W\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x90\x91_\x92`@Q\x91aIx\x83a.\xA9V[_\x83R_` \x84\x01R_`@\x84\x01R\x82\x94\x84T\x93` \x84\x01Q\x15\x93o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x90\x85\x15_\x14aV\xA9Wa\x0F\xFF\x87`\xB8\x1C\x16\x92[`@\x82\x01Q\x91_\x93\x88\x15_\x14aV\x9FW`\x01\x8B\x01T[\x97\x8As\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R\x8A`\xA0\x1C`\x02\x0B` \x85\x01R\x81`@\x85\x01R`\x80\x83\x01Qb@\0\0\x81\x16\x15\x15_\x14aV\x90Wb\xBF\xFF\xFF\x16aJ \x81a7eV[a\xFF\xFF\x88\x16aVmW\x91[\x82_`@\x86\x01Q\x12\x95b\x0FB@b\xFF\xFF\xFF\x83\x16\x10\x15aV@W[`@\x86\x01Q\x15aV(WPP\x8AaU\xB4W``\x84\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15aUgWPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16d\x01\0\x02v\xA3\x81\x11\x15aU<WP[`@Q\x9B\x8Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xE0\x82\x81\x81\x01\x10\x92\x01\x11\x17a\x1FyW\x95\x8E_`\xC0\x8F`\xE0\x81\x01`@R\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01R[\x81\x15\x90\x81\x15aU\x01W[PaS\xC8W\x8E\x8D\x8F\x8E\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84Q\x16\x83R` \x84\x01Q`\x02\x0B\x91\x89Q`\x02\x0B\x92\x83_\x81\x83\x07\x12\x91\x05\x03\x90\x15_\x14aRkW\x91\x82`\x05`\xFF\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95\x16\x93\x82`\x02\x0B`\x08\x1D`\x01\x0B_R\x01` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84`\xFF\x03\x1C\x90T\x16\x92\x83\x15\x15\x93\x84_\x14aRYW\x90aK\xD2`\xFF\x92a[\x8FV[\x90\x03\x16`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0B[\x90[\x15\x15`@\x84\x01R`\x02\x0B\x80` \x84\x01R\x13\x15aR-W[b\r\x89\xE8` \x82\x01Q`\x02\x0B\x12\x15aR\x1EW[\x8D`\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaL6` \x85\x01Q`\x02\x0BaAfV[\x16\x80``\x85\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x8C\x01Q\x16\x92\x83\x91\x15\x16\x81\x83\x10\x18\x91\x18\x02\x18o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x85\x01Q\x16b\xFF\xFF\xFF\x89\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x81\x10\x15\x91_\x88\x12_\x14aPyW\x84b\x0FB@\x03aL\xD2\x81\x8A_\x03aW9V[\x94\x84\x15aPhWaL\xE4\x83\x85\x83aZ1V[\x95[\x86\x81\x10aO\xADWP\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x93\x91`\x80\x95\x93\x97\x88\x91b\x0FB@\x82\x14_\x14aO\x9EWPP\x86[\x93[\x15aO\x90W\x91aM/\x92aY\xF1V[\x90[`\xC0\x83\x01R`\xA0\x82\x01R\x01R\x16\x90R\x85aOXW`\xA0\x8D\x01Q\x90_\x82\x12a2QW\x03\x95aMh\x8D`\xC0`\x80\x82\x01Q\x91\x01Q\x90a0\xADV[_\x81\x12a2QW\x88\x03\x97\x88\x13`\x01\x16a\x1E\\W\x8E\x8D\x8F\x8E[a\xFF\xFF\x8D\x16aO+W[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x85\x01Q\x16\x80aO\x18W[P\x8Es\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x86\x01Q\x16\x81\x14_\x14aN\xD7WP`@\x84\x01QaNGW[PPPP\x8D\x8D\x15_\x14aN;W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x01Q`\x02\x0B\x01`\x02\x0B[`\x02\x0B` \x82\x01R[\x96\x90\x96aK\x05V[` \x01Q`\x02\x0BaN*V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93`\x04aN\xB0\x94\x84\x15_\x14aN\xC9W` `\x02\x82\x01T\x93[\x01Q`\x02\x0B`\x02\x0B_R\x01` R`@_ \x91`\x01\x83\x01\x90\x81T\x90\x03\x90U`\x02\x82\x01\x90\x81T\x90\x03\x90UT`\x80\x1D\x90\x15aN\xBFW[\x82`@\x85\x01Q\x16aE|V[\x16`@\x82\x01R\x8D\x8F\x8E\x8EaM\xEFV[_\x03`\x0F\x0BaN\xA4V[` `\x01\x82\x01T\x94\x93aNpV[\x93\x91PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91PQ\x16\x81\x03aO\x01W[PaN3V[aO\n\x90aF\nV[`\x02\x0B` \x82\x01R_aN\xFBV[`\xC0\x84\x01Q`\x80\x1B\x04\x90\x9E\x01\x9D_aM\xA7V[\x9Cb\x0FB@\x8Da\xFF\xFF`\x80\x86\x01Q\x91\x16\x90`\xC0\x86\x01Q\x01\x02\x04\x90\x81`\xC0\x85\x01Q\x03`\xC0\x85\x01R\x01\x9CaM\x8AV[`\x80\x8D\x01Q`\xC0\x8E\x01Q\x01\x90_\x82\x12a2QW\x01\x95`\xA0\x8D\x01Q\x97_\x89\x12a2QW\x8F\x90\x8F\x8F\x91\x8F\x9BaO\x8A\x91a<\0V[\x9AaM\x80V[aO\x99\x92aZ\xE8V[aM/V[aO\xA8\x91\x89a\\\x1CV[aM\x1EV[\x96PPP\x91\x92P\x93\x83\x92\x82\x15\x86\x15\x17aP[Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x95`\x80\x93\x82\x15aO\xF6WaO\xEA\x87\x82\x84a\\\xBBV[\x80\x97\x8B\x01_\x03\x93aM V[\x87\x87\x11aP4WaP/aP*aP\"o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x8A``\x1BaI0V[\x8A\x85\x16a0\xADV[a]OV[aO\xEAV[aP/aP*aPVo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x8AaX>V[aP\"V[cO$a\xB8_R`\x04`\x1C\xFD[aPs\x83\x82\x86aY\x96V[\x95aL\xE6V[\x92\x94\x91\x93\x92\x84\x15aR\rWaP\x8F\x81\x83\x88aY\xF1V[\x95[\x86\x89\x10aP\xEAW`\x80\x93\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x92aP\xD7\x92\x80\x98[\x15aP\xDCW\x91aP\xC9\x92aZ1V[\x80\x95\x80b\x0FB@\x03\x91a\\\x1CV[aM1V[aP\xE5\x92aY\x96V[aP\xC9V[P\x94P\x90\x86\x85\x15\x83\x15\x17aP[W\x84\x15aQ\xE1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11aQ\x8EW\x87``\x1Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x16\x80\x82\x06\x15\x15\x91\x04\x01[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x81\x85\x11\x15aQ\x81Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97\x88aP\xD7\x93`\x80\x97\x03\x16[\x80\x98aP\xBAV[cC#\xA5U_R`\x04`\x1C\xFD[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x16aQ\xB9\x81l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x8BaX\xF7V[\x90\x80\x15aI:Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x8A\t\x15aQ9W`\x01\x01\x80aQ9W_\x80\xFD[aP\xD7\x83\x87aR\x08\x8Bs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x9A`\x80\x98a\\EV[aQzV[aR\x18\x81\x87\x84aZ\xE8V[\x95aP\x91V[` b\r\x89\xE8\x91\x01R\x8DaL\x0EV[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x91\x01R\x8DaK\xFBV[P`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0BaK\xE2V[`\x01`\x05\x91\x01\x91\x82`\x02\x0B`\x08\x1D`\x01\x0B_R\x01` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xFF\x84\x16\x1B\x01\x19\x90T\x16\x91\x82\x15\x91\x82\x15\x92\x83_\x14aS\x88Wa\x030W`\xFF\x84\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95_\x03\x16a\x01\xE0\x7F\x80@@UC\0RfD2\0\0P a\x06t\x050&\x02\0\0\x10u\x06 \x01v\x11pw`\xFC\x7F\xB6\xDBm\xB6\xDD\xDD\xDD\xDD\xD3M4\xD3I$\x92I!\x08B\x10\x8Cc\x18\xC69\xCEs\x9C\xFF\xFF\xFF\xFF\x84\x02`\xF8\x1C\x16\x1B`\xF7\x1C\x16~\x1F\r\x1E\x10\x0C\x1D\x07\x0F\t\x0B\x19\x13\x1C\x17\x06\x01\x0E\x11\x08\n\x1A\x14\x18\x02\x12\x1B\x15\x03\x16\x04\x05`\x1F\x85\x85\x16\x93\x83\x1Cc\xD7dS\xE0\x04\x16\x1A\x17\x03\x16`\x02\x0B\x90`\x02\x0B\x01`\x02\x0B\x02`\x02\x0B[\x90aK\xE4V[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x93P`\xFF\x81\x81\x16\x81\x03\x16`\x02\x0B\x90`\x02\x0B\x01`\x02\x0B\x02`\x02\x0BaS\x82V[\x97P\x91\x9AP\x9B\x98\x93\x9A\x91\x96\x9A\x97\x92\x94\x97` \x8A\x01Q`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8CQ\x16\x92\x16\x17\x17\x82Uo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8A\x01Q\x16\x80\x91\x03aT\xBCW[P\x82\x15aT\xB3W`\x02\x01U[\x15\x14aT\x9BW`@aTxaT\x81\x93\x94a8\\V[\x93\x01Q\x03a8\\V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x93V[aT\xAD\x90`@aT\x81\x93\x01Q\x03a8\\V[\x91a8\\V[`\x01\x01UaTcV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03\x83\x01T\x16\x17`\x03\x82\x01U_aTWV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91PQ\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x87\x01Q\x16\x14\x8FaK\x0FV[\x7F\x9EM|\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x8D`D\x91`@Q\x91\x7F|\x9Cn\x8F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x83\x01R`$\x82\x01R\xFD[``\x84\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aUgWPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DRc\x98\x8D&\x81\x10\x15aU<WPaJ\xB7V[\x9CP\x9CPP\x9BPPPPPPPPPP_\x92_\x92\x91\x90V[\x86aJEW\x7F\x96 bF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[b\xFF\xFF\xFFa\x0F\xFF\x89\x16\x91\x16\x80\x82\x02b\x0FB@\x80\x82\x06\x15\x15\x91\x04\x01\x91\x01\x03\x91aJ+V[P\x8A`\xD0\x1Cb\xFF\xFF\xFF\x16aJ V[`\x02\x8B\x01TaI\xD3V[a\x0F\xFF\x87`\xC4\x1C\x16\x92aI\xBDV[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14aW0Wp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\x80\x1B\x91\x03`\x80\x1C\x17\x90V[PPP`\x80\x1C\x90V[\x81\x81\x02\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x82\t\x90\x82\x80\x83\x10\x92\x03\x91\x80\x83\x03\x92\x83b\x0FB@\x11\x15a\x030W\x14aW\xB8W\x7F\xDE\x8Fl\xEF\xEDcEI\xB6,wWOr.\x1A\xC5~#\xF2M\x8F\xD5\xCBy\x0F\xB6Vh\xC2a9\x93b\x0FB@\x91\t\x90\x82\x82\x11\x90\x03`\xFA\x1B\x91\x03`\x06\x1C\x17\x02\x90V[PPb\x0FB@\x91P\x04\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14aX5Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\xA0\x1B\x91\x03``\x1C\x17\x90V[PPP``\x1C\x90V[\x90\x81``\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14aX\xF0Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[P\x91P\x04\x90V[\x91\x81\x83\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x85\t\x93\x83\x80\x86\x10\x95\x03\x94\x80\x86\x03\x95\x86\x85\x11\x15a\x030W\x14aY\x8EW\x90\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[PP\x91P\x04\x90V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`\x01\x95\x16\x91\x16\x03\x80`\xFF\x1D\x90\x81\x01\x18\x93\x16\x92aY\xE8\x81\x85aW\xC4V[\x93\t\x15\x15\x16\x01\x90V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80a7&\x95\x94\x16\x91\x16\x03\x80`\xFF\x1D\x90\x81\x01\x18\x91\x16aW\xC4V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x11aZ\xE2W[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x92\x83\x15aZ\xD6W{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaZ\xCA\x94\x81\x85\x16\x94\x03\x16\x91``\x1B\x16a\\\x1CV[\x90\x80\x82\x06\x15\x15\x91\x04\x01\x90V[b\xBF\xC9!_R`\x04`\x1C\xFD[\x90aZfV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x11a[\x89W[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x91\x82\x15aZ\xD6Wa7&\x93{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa[\x84\x94\x81\x85\x16\x94\x03\x16\x91``\x1B\x16aX\xF7V[aI0V[\x90a[\x1CV[\x80\x15a\x030W\x7F\x07\x06\x06\x05\x06\x02\x05\0\x06\x02\x03\x02\x05\x04\0\x01\x06\x05\x02\x05\x03\x03\x04\x01\x05\x05\x03\x04\0\0\0\0o\x84!\x08B\x10\x84!\x08\xCCc\x18\xC6\xDBmT\xBE\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x10`\x07\x1B\x83\x81\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x10`\x06\x1B\x17\x83\x81\x1Cc\xFF\xFF\xFF\xFF\x10`\x05\x1B\x17\x83\x81\x1Ca\xFF\xFF\x10`\x04\x1B\x17\x83\x81\x1C`\xFF\x10`\x03\x1B\x17\x92\x83\x1C\x1C`\x1F\x16\x1A\x17\x90V[\x92\x91\x90a\\*\x82\x82\x86aX\xF7V[\x93\x82\x15aI:W\ta\\8WV[\x90`\x01\x01\x90\x81\x15a\x030WV[\x91\x90\x81\x15a\\\xB6W{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91``\x1B\x16\x92\x16\x91\x82\x82\x02\x91\x83\x83\x83\x11\x91\x84\x04\x14\x16\x15a\\\xA9Wa7&\x92aP*\x92\x82\x03\x91a\\\x1CV[c\xF5\xC7\x87\xF1_R`\x04`\x1C\xFD[PP\x90V[\x90\x91\x80\x15a]IWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x81\x94``\x1B\x16\x92\x16\x80\x82\x02\x81a]\x0B\x84\x83aI0V[\x14a]1W[P\x90a] a]%\x92\x84aI0V[a0\xADV[\x80\x82\x06\x15\x15\x91\x04\x01\x16\x90V[\x83\x01\x83\x81\x10a]\x11W\x91Pa]E\x92a\\\x1CV[\x16\x90V[P\x90P\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x03a2QWV\xFE\xA1dsolcC\0\x08\x1A\0\n",
    );
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct BalanceDelta(alloy::sol_types::private::I256);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BalanceDelta>
        for alloy::sol_types::private::I256 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Int<256>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl BalanceDelta {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::I256) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::I256 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BalanceDelta {
            type RustType = alloy::sol_types::private::I256;
            type Token<'a> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BalanceDelta {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Currency(alloy::sol_types::private::Address);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Currency>
        for alloy::sol_types::private::Address {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<
                '_,
            > {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Address,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        self,
                    )
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::abi_encode_packed_to(
                    self,
                    out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::abi_encoded_size(
                    self,
                )
            }
        }
        #[automatically_derived]
        impl Currency {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::Address) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::Address {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Currency {
            type RustType = alloy::sol_types::private::Address;
            type Token<'a> = <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<
                'a,
            >;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::type_check(
                    token,
                )
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::detokenize(
                    token,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Currency {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                    rust,
                )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    out,
                )
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolId(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<PoolId>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl PoolId {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolId {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolId {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct ModifyLiquidityParams { int24 tickLower; int24 tickUpper; int256 liquidityDelta; bytes32 salt; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ModifyLiquidityParams {
        pub tickLower: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub tickUpper: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub liquidityDelta: alloy::sol_types::private::I256,
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::I256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ModifyLiquidityParams> for UnderlyingRustTuple<'_> {
            fn from(value: ModifyLiquidityParams) -> Self {
                (value.tickLower, value.tickUpper, value.liquidityDelta, value.salt)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ModifyLiquidityParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    tickLower: tuple.0,
                    tickUpper: tuple.1,
                    liquidityDelta: tuple.2,
                    salt: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ModifyLiquidityParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ModifyLiquidityParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickLower),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickUpper),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidityDelta),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ModifyLiquidityParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ModifyLiquidityParams {
            const NAME: &'static str = "ModifyLiquidityParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ModifyLiquidityParams(int24 tickLower,int24 tickUpper,int256 liquidityDelta,bytes32 salt)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickLower)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickUpper)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.liquidityDelta,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.salt)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ModifyLiquidityParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickLower,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickUpper,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.liquidityDelta,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.salt)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickLower,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickUpper,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.liquidityDelta,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.salt,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct PoolKey { Currency currency0; Currency currency1; uint24 fee; int24 tickSpacing; address hooks; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolKey {
        pub currency0: <Currency as alloy::sol_types::SolType>::RustType,
        pub currency1: <Currency as alloy::sol_types::SolType>::RustType,
        pub fee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub tickSpacing: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub hooks: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            Currency,
            Currency,
            alloy::sol_types::sol_data::Uint<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Currency as alloy::sol_types::SolType>::RustType,
            <Currency as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolKey> for UnderlyingRustTuple<'_> {
            fn from(value: PoolKey) -> Self {
                (
                    value.currency0,
                    value.currency1,
                    value.fee,
                    value.tickSpacing,
                    value.hooks,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolKey {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currency0: tuple.0,
                    currency1: tuple.1,
                    fee: tuple.2,
                    tickSpacing: tuple.3,
                    hooks: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PoolKey {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PoolKey {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency0),
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency1),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.hooks,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolKey {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PoolKey {
            const NAME: &'static str = "PoolKey";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PoolKey(address currency0,address currency1,uint24 fee,int24 tickSpacing,address hooks)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency0,
                        )
                        .0,
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency1,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.fee)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickSpacing)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.hooks,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolKey {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency0,
                    )
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency1,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.fee)
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickSpacing,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.hooks,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency0,
                    out,
                );
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency1,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.fee, out);
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickSpacing,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.hooks,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SwapParams { bool zeroForOne; int256 amountSpecified; uint160 sqrtPriceLimitX96; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SwapParams {
        pub zeroForOne: bool,
        pub amountSpecified: alloy::sol_types::private::I256,
        pub sqrtPriceLimitX96: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::Uint<160>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            bool,
            alloy::sol_types::private::I256,
            <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapParams> for UnderlyingRustTuple<'_> {
            fn from(value: SwapParams) -> Self {
                (value.zeroForOne, value.amountSpecified, value.sqrtPriceLimitX96)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SwapParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    zeroForOne: tuple.0,
                    amountSpecified: tuple.1,
                    sqrtPriceLimitX96: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SwapParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SwapParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.zeroForOne,
                    ),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountSpecified),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self.sqrtPriceLimitX96),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SwapParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SwapParams {
            const NAME: &'static str = "SwapParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SwapParams(bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.zeroForOne,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.amountSpecified,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sqrtPriceLimitX96,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SwapParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.zeroForOne,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amountSpecified,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sqrtPriceLimitX96,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.zeroForOne,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amountSpecified,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sqrtPriceLimitX96,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AlreadyUnlocked()` and selector `0x5090d6c6`.
```solidity
error AlreadyUnlocked();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AlreadyUnlocked {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyUnlocked> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyUnlocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyUnlocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyUnlocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyUnlocked()";
            const SELECTOR: [u8; 4] = [80u8, 144u8, 214u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CurrenciesOutOfOrderOrEqual(address,address)` and selector `0x6e6c9830`.
```solidity
error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct CurrenciesOutOfOrderOrEqual {
        pub currency0: alloy::sol_types::private::Address,
        pub currency1: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CurrenciesOutOfOrderOrEqual>
        for UnderlyingRustTuple<'_> {
            fn from(value: CurrenciesOutOfOrderOrEqual) -> Self {
                (value.currency0, value.currency1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CurrenciesOutOfOrderOrEqual {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currency0: tuple.0,
                    currency1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CurrenciesOutOfOrderOrEqual {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CurrenciesOutOfOrderOrEqual(address,address)";
            const SELECTOR: [u8; 4] = [110u8, 108u8, 152u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.currency0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.currency1,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `CurrencyNotSettled()` and selector `0x5212cba1`.
```solidity
error CurrencyNotSettled();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct CurrencyNotSettled {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CurrencyNotSettled> for UnderlyingRustTuple<'_> {
            fn from(value: CurrencyNotSettled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CurrencyNotSettled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CurrencyNotSettled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CurrencyNotSettled()";
            const SELECTOR: [u8; 4] = [82u8, 18u8, 203u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `DelegateCallNotAllowed()` and selector `0x0d89438e`.
```solidity
error DelegateCallNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct DelegateCallNotAllowed {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DelegateCallNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: DelegateCallNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DelegateCallNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DelegateCallNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DelegateCallNotAllowed()";
            const SELECTOR: [u8; 4] = [13u8, 137u8, 67u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidCaller()` and selector `0x48f5c3ed`.
```solidity
error InvalidCaller();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidCaller {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCaller> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCaller()";
            const SELECTOR: [u8; 4] = [72u8, 245u8, 195u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ManagerLocked()` and selector `0x54e3ca0d`.
```solidity
error ManagerLocked();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ManagerLocked {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ManagerLocked> for UnderlyingRustTuple<'_> {
            fn from(value: ManagerLocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ManagerLocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ManagerLocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ManagerLocked()";
            const SELECTOR: [u8; 4] = [84u8, 227u8, 202u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `MustClearExactPositiveDelta()` and selector `0xbda73abf`.
```solidity
error MustClearExactPositiveDelta();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MustClearExactPositiveDelta {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MustClearExactPositiveDelta>
        for UnderlyingRustTuple<'_> {
            fn from(value: MustClearExactPositiveDelta) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for MustClearExactPositiveDelta {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MustClearExactPositiveDelta {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MustClearExactPositiveDelta()";
            const SELECTOR: [u8; 4] = [189u8, 167u8, 58u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NonzeroNativeValue()` and selector `0xb0ec849e`.
```solidity
error NonzeroNativeValue();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct NonzeroNativeValue {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NonzeroNativeValue> for UnderlyingRustTuple<'_> {
            fn from(value: NonzeroNativeValue) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NonzeroNativeValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NonzeroNativeValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NonzeroNativeValue()";
            const SELECTOR: [u8; 4] = [176u8, 236u8, 132u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `PoolNotInitialized()` and selector `0x486aa307`.
```solidity
error PoolNotInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolNotInitialized {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolNotInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: PoolNotInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PoolNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PoolNotInitialized()";
            const SELECTOR: [u8; 4] = [72u8, 106u8, 163u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ProtocolFeeCannotBeFetched()` and selector `0x1ee49702`.
```solidity
error ProtocolFeeCannotBeFetched();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ProtocolFeeCannotBeFetched {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProtocolFeeCannotBeFetched>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProtocolFeeCannotBeFetched) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProtocolFeeCannotBeFetched {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProtocolFeeCannotBeFetched {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProtocolFeeCannotBeFetched()";
            const SELECTOR: [u8; 4] = [30u8, 228u8, 151u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ProtocolFeeTooLarge(uint24)` and selector `0xa7abe2f7`.
```solidity
error ProtocolFeeTooLarge(uint24 fee);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ProtocolFeeTooLarge {
        pub fee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProtocolFeeTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: ProtocolFeeTooLarge) -> Self {
                (value.fee,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProtocolFeeTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { fee: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProtocolFeeTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProtocolFeeTooLarge(uint24)";
            const SELECTOR: [u8; 4] = [167u8, 171u8, 226u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                )
            }
        }
    };
    /**Custom error with signature `SwapAmountCannotBeZero()` and selector `0xbe8b8507`.
```solidity
error SwapAmountCannotBeZero();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SwapAmountCannotBeZero {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapAmountCannotBeZero> for UnderlyingRustTuple<'_> {
            fn from(value: SwapAmountCannotBeZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SwapAmountCannotBeZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapAmountCannotBeZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapAmountCannotBeZero()";
            const SELECTOR: [u8; 4] = [190u8, 139u8, 133u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TickSpacingTooLarge(int24)` and selector `0xb70024f8`.
```solidity
error TickSpacingTooLarge(int24 tickSpacing);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TickSpacingTooLarge {
        pub tickSpacing: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TickSpacingTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: TickSpacingTooLarge) -> Self {
                (value.tickSpacing,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TickSpacingTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { tickSpacing: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TickSpacingTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TickSpacingTooLarge(int24)";
            const SELECTOR: [u8; 4] = [183u8, 0u8, 36u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                )
            }
        }
    };
    /**Custom error with signature `TickSpacingTooSmall(int24)` and selector `0xe9e90588`.
```solidity
error TickSpacingTooSmall(int24 tickSpacing);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TickSpacingTooSmall {
        pub tickSpacing: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TickSpacingTooSmall> for UnderlyingRustTuple<'_> {
            fn from(value: TickSpacingTooSmall) -> Self {
                (value.tickSpacing,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TickSpacingTooSmall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { tickSpacing: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TickSpacingTooSmall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TickSpacingTooSmall(int24)";
            const SELECTOR: [u8; 4] = [233u8, 233u8, 5u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                )
            }
        }
    };
    /**Custom error with signature `UnauthorizedDynamicLPFeeUpdate()` and selector `0x30d21641`.
```solidity
error UnauthorizedDynamicLPFeeUpdate();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UnauthorizedDynamicLPFeeUpdate {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedDynamicLPFeeUpdate>
        for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedDynamicLPFeeUpdate) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UnauthorizedDynamicLPFeeUpdate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedDynamicLPFeeUpdate {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedDynamicLPFeeUpdate()";
            const SELECTOR: [u8; 4] = [48u8, 210u8, 22u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256,uint256)` and selector `0xb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a7`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8,
                253u8,
                80u8,
                113u8,
                131u8,
                88u8,
                135u8,
                86u8,
                122u8,
                6u8,
                113u8,
                21u8,
                17u8,
                33u8,
                137u8,
                77u8,
                220u8,
                204u8,
                40u8,
                66u8,
                241u8,
                209u8,
                11u8,
                237u8,
                173u8,
                19u8,
                224u8,
                209u8,
                124u8,
                172u8,
                233u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    id: topics.3,
                    amount: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.spender.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Donate(bytes32,address,uint256,uint256)` and selector `0x29ef05caaff9404b7cb6d1c0e9bbae9eaa7ab2541feba1a9c4248594c08156cb`.
```solidity
event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Donate {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount0: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amount1: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Donate {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Donate(bytes32,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                41u8,
                239u8,
                5u8,
                202u8,
                175u8,
                249u8,
                64u8,
                75u8,
                124u8,
                182u8,
                209u8,
                192u8,
                233u8,
                187u8,
                174u8,
                158u8,
                170u8,
                122u8,
                178u8,
                84u8,
                31u8,
                235u8,
                161u8,
                169u8,
                196u8,
                36u8,
                133u8,
                148u8,
                192u8,
                129u8,
                86u8,
                203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    sender: topics.2,
                    amount0: data.0,
                    amount1: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.sender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Donate {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Donate> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Donate) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialize(bytes32,address,address,uint24,int24,address,uint160,int24)` and selector `0xdd466e674ea557f56295e2d0218a125ea4b4f0f6f3307b95f85e6110838d6438`.
```solidity
event Initialize(PoolId indexed id, Currency indexed currency0, Currency indexed currency1, uint24 fee, int24 tickSpacing, address hooks, uint160 sqrtPriceX96, int24 tick);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Initialize {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub currency0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub currency1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub fee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub tickSpacing: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub hooks: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sqrtPriceX96: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub tick: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialize {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Int<24>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "Initialize(bytes32,address,address,uint24,int24,address,uint160,int24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                70u8,
                110u8,
                103u8,
                78u8,
                165u8,
                87u8,
                245u8,
                98u8,
                149u8,
                226u8,
                208u8,
                33u8,
                138u8,
                18u8,
                94u8,
                164u8,
                180u8,
                240u8,
                246u8,
                243u8,
                48u8,
                123u8,
                149u8,
                248u8,
                94u8,
                97u8,
                16u8,
                131u8,
                141u8,
                100u8,
                56u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    currency0: topics.2,
                    currency1: topics.3,
                    fee: data.0,
                    tickSpacing: data.1,
                    hooks: data.2,
                    sqrtPriceX96: data.3,
                    tick: data.4,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.hooks,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self.sqrtPriceX96),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tick),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.id.clone(),
                    self.currency0.clone(),
                    self.currency1.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.currency0);
                out[3usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.currency1);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialize {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialize> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialize) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ModifyLiquidity(bytes32,address,int24,int24,int256,bytes32)` and selector `0xf208f4912782fd25c7f114ca3723a2d5dd6f3bcc3ac8db5af63baa85f711d5ec`.
```solidity
event ModifyLiquidity(PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ModifyLiquidity {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tickLower: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub tickUpper: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub liquidityDelta: alloy::sol_types::private::I256,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ModifyLiquidity {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ModifyLiquidity(bytes32,address,int24,int24,int256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                242u8,
                8u8,
                244u8,
                145u8,
                39u8,
                130u8,
                253u8,
                37u8,
                199u8,
                241u8,
                20u8,
                202u8,
                55u8,
                35u8,
                162u8,
                213u8,
                221u8,
                111u8,
                59u8,
                204u8,
                58u8,
                200u8,
                219u8,
                90u8,
                246u8,
                59u8,
                170u8,
                133u8,
                247u8,
                17u8,
                213u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    sender: topics.2,
                    tickLower: data.0,
                    tickUpper: data.1,
                    liquidityDelta: data.2,
                    salt: data.3,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickLower),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickUpper),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidityDelta),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.sender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ModifyLiquidity {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ModifyLiquidity> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ModifyLiquidity) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorSet(address,address,bool)` and selector `0xceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267`.
```solidity
event OperatorSet(address indexed owner, address indexed operator, bool approved);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorSet {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorSet(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                206u8,
                181u8,
                118u8,
                217u8,
                241u8,
                94u8,
                78u8,
                32u8,
                15u8,
                219u8,
                80u8,
                150u8,
                214u8,
                77u8,
                93u8,
                253u8,
                102u8,
                126u8,
                22u8,
                222u8,
                242u8,
                12u8,
                30u8,
                239u8,
                209u8,
                66u8,
                86u8,
                216u8,
                227u8,
                250u8,
                162u8,
                103u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    operator: topics.2,
                    approved: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed user, address indexed newOwner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.user.clone(), self.newOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ProtocolFeeControllerUpdated(address)` and selector `0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc`.
```solidity
event ProtocolFeeControllerUpdated(address indexed protocolFeeController);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ProtocolFeeControllerUpdated {
        #[allow(missing_docs)]
        pub protocolFeeController: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFeeControllerUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ProtocolFeeControllerUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                180u8,
                189u8,
                142u8,
                245u8,
                61u8,
                246u8,
                144u8,
                185u8,
                148u8,
                61u8,
                51u8,
                24u8,
                153u8,
                96u8,
                6u8,
                219u8,
                184u8,
                42u8,
                37u8,
                245u8,
                71u8,
                25u8,
                216u8,
                200u8,
                3u8,
                91u8,
                81u8,
                106u8,
                42u8,
                91u8,
                138u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    protocolFeeController: topics.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.protocolFeeController.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.protocolFeeController,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolFeeControllerUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolFeeControllerUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ProtocolFeeControllerUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ProtocolFeeUpdated(bytes32,uint24)` and selector `0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9`.
```solidity
event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ProtocolFeeUpdated {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub protocolFee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFeeUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ProtocolFeeUpdated(bytes32,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                233u8,
                196u8,
                37u8,
                147u8,
                231u8,
                31u8,
                132u8,
                64u8,
                59u8,
                132u8,
                53u8,
                44u8,
                209u8,
                104u8,
                214u8,
                147u8,
                226u8,
                201u8,
                252u8,
                209u8,
                253u8,
                188u8,
                195u8,
                254u8,
                178u8,
                29u8,
                146u8,
                180u8,
                62u8,
                102u8,
                150u8,
                249u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    protocolFee: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.protocolFee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolFeeUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolFeeUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProtocolFeeUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Swap(bytes32,address,int128,int128,uint160,uint128,int24,uint24)` and selector `0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f`.
```solidity
event Swap(PoolId indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Swap {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount0: i128,
        #[allow(missing_docs)]
        pub amount1: i128,
        #[allow(missing_docs)]
        pub sqrtPriceX96: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub liquidity: u128,
        #[allow(missing_docs)]
        pub tick: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub fee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Swap {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Int<128>,
                alloy::sol_types::sol_data::Int<128>,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Uint<128>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Swap(bytes32,address,int128,int128,uint160,uint128,int24,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                64u8,
                233u8,
                206u8,
                203u8,
                159u8,
                95u8,
                31u8,
                28u8,
                91u8,
                156u8,
                151u8,
                222u8,
                194u8,
                145u8,
                123u8,
                126u8,
                233u8,
                46u8,
                87u8,
                186u8,
                85u8,
                99u8,
                112u8,
                141u8,
                172u8,
                169u8,
                77u8,
                216u8,
                74u8,
                215u8,
                17u8,
                47u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    sender: topics.2,
                    amount0: data.0,
                    amount1: data.1,
                    sqrtPriceX96: data.2,
                    liquidity: data.3,
                    tick: data.4,
                    fee: data.5,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0),
                    <alloy::sol_types::sol_data::Int<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self.sqrtPriceX96),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidity),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tick),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.sender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Swap {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Swap> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Swap) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,address,uint256,uint256)` and selector `0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859`.
```solidity
event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                27u8,
                61u8,
                126u8,
                219u8,
                46u8,
                156u8,
                11u8,
                14u8,
                124u8,
                82u8,
                91u8,
                32u8,
                170u8,
                174u8,
                240u8,
                245u8,
                148u8,
                13u8,
                46u8,
                215u8,
                22u8,
                99u8,
                199u8,
                211u8,
                146u8,
                102u8,
                236u8,
                175u8,
                172u8,
                114u8,
                136u8,
                89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: data.0,
                    from: topics.1,
                    to: topics.2,
                    id: topics.3,
                    amount: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.from.clone(),
                    self.to.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 controllerGasLimit);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub controllerGasLimit: alloy::sol_types::private::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.controllerGasLimit,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        controllerGasLimit: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.controllerGasLimit),
                )
            }
        }
    };
    /**Function with signature `allowance(address,address,uint256)` and selector `0x598af9e7`.
```solidity
function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allowanceCall {
        pub owner: alloy::sol_types::private::Address,
        pub spender: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`allowance(address,address,uint256)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        id: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 138u8, 249u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256,uint256)` and selector `0x426a8493`.
```solidity
function approve(address spender, uint256 id, uint256 amount) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct approveCall {
        pub spender: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct approveReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [66u8, 106u8, 132u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address,uint256)` and selector `0x00fdd58e`.
```solidity
function balanceOf(address owner, uint256 id) external view returns (uint256 balance);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        pub owner: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`balanceOf(address,uint256)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        pub balance: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.owner, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        id: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value.balance,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { balance: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address,uint256)";
            const SELECTOR: [u8; 4] = [0u8, 253u8, 213u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256,uint256)` and selector `0xf5298aca`.
```solidity
function burn(address from, uint256 id, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct burnCall {
        pub from: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value.from, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [245u8, 41u8, 138u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clear(address,uint256)` and selector `0x80f0b44c`.
```solidity
function clear(Currency currency, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct clearCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`clear(address,uint256)`](clearCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct clearReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Currency,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Currency as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clearCall> for UnderlyingRustTuple<'_> {
                fn from(value: clearCall) -> Self {
                    (value.currency, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clearCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        currency: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clearReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clearReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clearReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clearCall {
            type Parameters<'a> = (Currency, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clearReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clear(address,uint256)";
            const SELECTOR: [u8; 4] = [128u8, 240u8, 180u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `collectProtocolFees(address,address,uint256)` and selector `0x8161b874`.
```solidity
function collectProtocolFees(address recipient, Currency currency, uint256 amount) external returns (uint256 amountCollected);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct collectProtocolFeesCall {
        pub recipient: alloy::sol_types::private::Address,
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`collectProtocolFees(address,address,uint256)`](collectProtocolFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct collectProtocolFeesReturn {
        pub amountCollected: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                Currency,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <Currency as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collectProtocolFeesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: collectProtocolFeesCall) -> Self {
                    (value.recipient, value.currency, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for collectProtocolFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        recipient: tuple.0,
                        currency: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collectProtocolFeesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: collectProtocolFeesReturn) -> Self {
                    (value.amountCollected,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for collectProtocolFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amountCollected: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for collectProtocolFeesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                Currency,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = collectProtocolFeesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "collectProtocolFees(address,address,uint256)";
            const SELECTOR: [u8; 4] = [129u8, 97u8, 184u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `donate((address,address,uint24,int24,address),uint256,uint256,bytes)` and selector `0x234266d7`.
```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData) external returns (BalanceDelta delta);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct donateCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub amount0: alloy::sol_types::private::U256,
        pub amount1: alloy::sol_types::private::U256,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`donate((address,address,uint24,int24,address),uint256,uint256,bytes)`](donateCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct donateReturn {
        pub delta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<donateCall> for UnderlyingRustTuple<'_> {
                fn from(value: donateCall) -> Self {
                    (value.key, value.amount0, value.amount1, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for donateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        amount0: tuple.1,
                        amount1: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<donateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: donateReturn) -> Self {
                    (value.delta,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for donateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delta: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for donateCall {
            type Parameters<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = donateReturn;
            type ReturnTuple<'a> = (BalanceDelta,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "donate((address,address,uint24,int24,address),uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [35u8, 66u8, 102u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32)` and selector `0x1e2eaeaf`.
```solidity
function extsload(bytes32 slot) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_0Call {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`extsload(bytes32)`](extsload_0Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Call) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32)";
            const SELECTOR: [u8; 4] = [30u8, 46u8, 174u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32,uint256)` and selector `0x35fd631a`.
```solidity
function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_1Call {
        pub startSlot: alloy::sol_types::private::FixedBytes<32>,
        pub nSlots: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`extsload(bytes32,uint256)`](extsload_1Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_1Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Call) -> Self {
                    (value.startSlot, value.nSlots)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startSlot: tuple.0,
                        nSlots: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [53u8, 253u8, 99u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startSlot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nSlots),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32[])` and selector `0xdbd035ff`.
```solidity
function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_2Call {
        pub slots: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`extsload(bytes32[])`](extsload_2Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_2Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_2Call) -> Self {
                    (value.slots,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slots: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_2Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32[])";
            const SELECTOR: [u8; 4] = [219u8, 208u8, 53u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.slots),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exttload(bytes32[])` and selector `0x9bf6645f`.
```solidity
function exttload(bytes32[] memory slots) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_0Call {
        pub slots: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`exttload(bytes32[])`](exttload_0Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_0Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_0Call) -> Self {
                    (value.slots,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slots: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exttload_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exttload_0Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exttload(bytes32[])";
            const SELECTOR: [u8; 4] = [155u8, 246u8, 100u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.slots),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exttload(bytes32)` and selector `0xf135baaa`.
```solidity
function exttload(bytes32 slot) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_1Call {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`exttload(bytes32)`](exttload_1Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_1Call) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exttload_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exttload_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exttload(bytes32)";
            const SELECTOR: [u8; 4] = [241u8, 53u8, 186u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize((address,address,uint24,int24,address),uint160,bytes)` and selector `0x695c5bf5`.
```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes memory hookData) external returns (int24 tick);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub sqrtPriceX96: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`initialize((address,address,uint24,int24,address),uint160,bytes)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeReturn {
        pub tick: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.key, value.sqrtPriceX96, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        sqrtPriceX96: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    (value.tick,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tick: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize((address,address,uint24,int24,address),uint160,bytes)";
            const SELECTOR: [u8; 4] = [105u8, 92u8, 91u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self.sqrtPriceX96),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isOperator(address,address)` and selector `0xb6363cf2`.
```solidity
function isOperator(address owner, address operator) external view returns (bool isOperator);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isOperatorCall {
        pub owner: alloy::sol_types::private::Address,
        pub operator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isOperator(address,address)`](isOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isOperatorReturn {
        pub isOperator: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorCall) -> Self {
                    (value.owner, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorReturn) -> Self {
                    (value.isOperator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { isOperator: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperator(address,address)";
            const SELECTOR: [u8; 4] = [182u8, 54u8, 60u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256,uint256)` and selector `0x156e29f6`.
```solidity
function mint(address to, uint256 id, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct mintCall {
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value.to, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [21u8, 110u8, 41u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)` and selector `0x5a6bcfda`.
```solidity
function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes memory hookData) external returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct modifyLiquidityCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub params: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)`](modifyLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct modifyLiquidityReturn {
        pub callerDelta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
        pub feesAccrued: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<modifyLiquidityCall> for UnderlyingRustTuple<'_> {
                fn from(value: modifyLiquidityCall) -> Self {
                    (value.key, value.params, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for modifyLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        params: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta, BalanceDelta);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<modifyLiquidityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: modifyLiquidityReturn) -> Self {
                    (value.callerDelta, value.feesAccrued)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for modifyLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        callerDelta: tuple.0,
                        feesAccrued: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for modifyLiquidityCall {
            type Parameters<'a> = (
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = modifyLiquidityReturn;
            type ReturnTuple<'a> = (BalanceDelta, BalanceDelta);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)";
            const SELECTOR: [u8; 4] = [90u8, 107u8, 207u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `protocolFeeController()` and selector `0xf02de3b2`.
```solidity
function protocolFeeController() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeeControllerCall {}
    ///Container type for the return parameters of the [`protocolFeeController()`](protocolFeeControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeeControllerReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeeControllerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeeControllerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFeeControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeeControllerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeeControllerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFeeControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFeeControllerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = protocolFeeControllerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFeeController()";
            const SELECTOR: [u8; 4] = [240u8, 45u8, 227u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `protocolFeesAccrued(address)` and selector `0x97e8cd4e`.
```solidity
function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeesAccruedCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`protocolFeesAccrued(address)`](protocolFeesAccruedCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeesAccruedReturn {
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Currency,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Currency as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeesAccruedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeesAccruedCall) -> Self {
                    (value.currency,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFeesAccruedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currency: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeesAccruedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeesAccruedReturn) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFeesAccruedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFeesAccruedCall {
            type Parameters<'a> = (Currency,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = protocolFeesAccruedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFeesAccrued(address)";
            const SELECTOR: [u8; 4] = [151u8, 232u8, 205u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Currency as alloy_sol_types::SolType>::tokenize(&self.currency),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setOperator(address,bool)` and selector `0x558a7297`.
```solidity
function setOperator(address operator, bool approved) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorCall {
        pub operator: alloy::sol_types::private::Address,
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setOperator(address,bool)`](setOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        approved: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperator(address,bool)";
            const SELECTOR: [u8; 4] = [85u8, 138u8, 114u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setProtocolFee((address,address,uint24,int24,address),uint24)` and selector `0x7e87ce7d`.
```solidity
function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub newProtocolFee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setProtocolFee((address,address,uint24,int24,address),uint24)`](setProtocolFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeCall) -> Self {
                    (value.key, value.newProtocolFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProtocolFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        newProtocolFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFeeCall {
            type Parameters<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolFee((address,address,uint24,int24,address),uint24)";
            const SELECTOR: [u8; 4] = [126u8, 135u8, 206u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.newProtocolFee),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setProtocolFeeController(address)` and selector `0x2d771389`.
```solidity
function setProtocolFeeController(address controller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeControllerCall {
        pub controller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setProtocolFeeController(address)`](setProtocolFeeControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeControllerReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeControllerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeControllerCall) -> Self {
                    (value.controller,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFeeControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { controller: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeControllerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeControllerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFeeControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFeeControllerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFeeControllerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolFeeController(address)";
            const SELECTOR: [u8; 4] = [45u8, 119u8, 19u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.controller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `settle()` and selector `0x11da60b4`.
```solidity
function settle() external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleCall {}
    ///Container type for the return parameters of the [`settle()`](settleCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleCall> for UnderlyingRustTuple<'_> {
                fn from(value: settleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: settleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for settleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = settleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "settle()";
            const SELECTOR: [u8; 4] = [17u8, 218u8, 96u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `settleFor(address)` and selector `0x3dd45adb`.
```solidity
function settleFor(address recipient) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleForCall {
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`settleFor(address)`](settleForCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleForReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleForCall> for UnderlyingRustTuple<'_> {
                fn from(value: settleForCall) -> Self {
                    (value.recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleForCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleForReturn> for UnderlyingRustTuple<'_> {
                fn from(value: settleForReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleForReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for settleForCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = settleForReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "settleFor(address)";
            const SELECTOR: [u8; 4] = [61u8, 212u8, 90u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)` and selector `0xf3cd914c`.
```solidity
function swap(PoolKey memory key, SwapParams memory params, bytes memory hookData) external returns (BalanceDelta swapDelta);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub params: <SwapParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)`](swapCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapReturn {
        pub swapDelta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                SwapParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <SwapParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapCall> for UnderlyingRustTuple<'_> {
                fn from(value: swapCall) -> Self {
                    (value.key, value.params, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        params: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: swapReturn) -> Self {
                    (value.swapDelta,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { swapDelta: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for swapCall {
            type Parameters<'a> = (
                PoolKey,
                SwapParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = swapReturn;
            type ReturnTuple<'a> = (BalanceDelta,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)";
            const SELECTOR: [u8; 4] = [243u8, 205u8, 145u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <SwapParams as alloy_sol_types::SolType>::tokenize(&self.params),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sync(address)` and selector `0xa5841194`.
```solidity
function sync(Currency currency) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct syncCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`sync(address)`](syncCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct syncReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Currency,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Currency as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syncCall> for UnderlyingRustTuple<'_> {
                fn from(value: syncCall) -> Self {
                    (value.currency,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currency: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: syncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syncCall {
            type Parameters<'a> = (Currency,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = syncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sync(address)";
            const SELECTOR: [u8; 4] = [165u8, 132u8, 17u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Currency as alloy_sol_types::SolType>::tokenize(&self.currency),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `take(address,address,uint256)` and selector `0x0b0d9c09`.
```solidity
function take(Currency currency, address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct takeCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
        pub to: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`take(address,address,uint256)`](takeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct takeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Currency,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Currency as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<takeCall> for UnderlyingRustTuple<'_> {
                fn from(value: takeCall) -> Self {
                    (value.currency, value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for takeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        currency: tuple.0,
                        to: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<takeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: takeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for takeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for takeCall {
            type Parameters<'a> = (
                Currency,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = takeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "take(address,address,uint256)";
            const SELECTOR: [u8; 4] = [11u8, 13u8, 156u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256,uint256)` and selector `0x095bcdb6`.
```solidity
function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferCall {
        pub receiver: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.receiver, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiver: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 91u8, 205u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256,uint256)` and selector `0xfe99049a`.
```solidity
function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferFromCall {
        pub sender: alloy::sol_types::private::Address,
        pub receiver: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.sender, value.receiver, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sender: tuple.0,
                        receiver: tuple.1,
                        id: tuple.2,
                        amount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [254u8, 153u8, 4u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unlock(bytes)` and selector `0x48c89491`.
```solidity
function unlock(bytes memory data) external returns (bytes memory result);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unlockCall {
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`unlock(bytes)`](unlockCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unlockReturn {
        pub result: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: unlockCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unlockReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unlockCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unlockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unlock(bytes)";
            const SELECTOR: [u8; 4] = [72u8, 200u8, 148u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateDynamicLPFee((address,address,uint24,int24,address),uint24)` and selector `0x52759651`.
```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateDynamicLPFeeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub newDynamicLPFee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`updateDynamicLPFee((address,address,uint24,int24,address),uint24)`](updateDynamicLPFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateDynamicLPFeeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDynamicLPFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateDynamicLPFeeCall) -> Self {
                    (value.key, value.newDynamicLPFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateDynamicLPFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        newDynamicLPFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDynamicLPFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateDynamicLPFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateDynamicLPFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateDynamicLPFeeCall {
            type Parameters<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateDynamicLPFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateDynamicLPFee((address,address,uint24,int24,address),uint24)";
            const SELECTOR: [u8; 4] = [82u8, 117u8, 150u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.newDynamicLPFee),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`PoolManager`](self) function calls.
    pub enum PoolManagerCalls {
        allowance(allowanceCall),
        approve(approveCall),
        balanceOf(balanceOfCall),
        burn(burnCall),
        clear(clearCall),
        collectProtocolFees(collectProtocolFeesCall),
        donate(donateCall),
        extsload_0(extsload_0Call),
        extsload_1(extsload_1Call),
        extsload_2(extsload_2Call),
        exttload_0(exttload_0Call),
        exttload_1(exttload_1Call),
        initialize(initializeCall),
        isOperator(isOperatorCall),
        mint(mintCall),
        modifyLiquidity(modifyLiquidityCall),
        owner(ownerCall),
        protocolFeeController(protocolFeeControllerCall),
        protocolFeesAccrued(protocolFeesAccruedCall),
        setOperator(setOperatorCall),
        setProtocolFee(setProtocolFeeCall),
        setProtocolFeeController(setProtocolFeeControllerCall),
        settle(settleCall),
        settleFor(settleForCall),
        supportsInterface(supportsInterfaceCall),
        swap(swapCall),
        sync(syncCall),
        take(takeCall),
        transfer(transferCall),
        transferFrom(transferFromCall),
        transferOwnership(transferOwnershipCall),
        unlock(unlockCall),
        updateDynamicLPFee(updateDynamicLPFeeCall),
    }
    #[automatically_derived]
    impl PoolManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 253u8, 213u8, 142u8],
            [1u8, 255u8, 201u8, 167u8],
            [9u8, 91u8, 205u8, 182u8],
            [11u8, 13u8, 156u8, 9u8],
            [17u8, 218u8, 96u8, 180u8],
            [21u8, 110u8, 41u8, 246u8],
            [30u8, 46u8, 174u8, 175u8],
            [35u8, 66u8, 102u8, 215u8],
            [45u8, 119u8, 19u8, 137u8],
            [53u8, 253u8, 99u8, 26u8],
            [61u8, 212u8, 90u8, 219u8],
            [66u8, 106u8, 132u8, 147u8],
            [72u8, 200u8, 148u8, 145u8],
            [82u8, 117u8, 150u8, 81u8],
            [85u8, 138u8, 114u8, 151u8],
            [89u8, 138u8, 249u8, 231u8],
            [90u8, 107u8, 207u8, 218u8],
            [105u8, 92u8, 91u8, 245u8],
            [126u8, 135u8, 206u8, 125u8],
            [128u8, 240u8, 180u8, 76u8],
            [129u8, 97u8, 184u8, 116u8],
            [141u8, 165u8, 203u8, 91u8],
            [151u8, 232u8, 205u8, 78u8],
            [155u8, 246u8, 100u8, 95u8],
            [165u8, 132u8, 17u8, 148u8],
            [182u8, 54u8, 60u8, 242u8],
            [219u8, 208u8, 53u8, 255u8],
            [240u8, 45u8, 227u8, 178u8],
            [241u8, 53u8, 186u8, 170u8],
            [242u8, 253u8, 227u8, 139u8],
            [243u8, 205u8, 145u8, 76u8],
            [245u8, 41u8, 138u8, 202u8],
            [254u8, 153u8, 4u8, 154u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for PoolManagerCalls {
        const NAME: &'static str = "PoolManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 33usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::clear(_) => <clearCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::collectProtocolFees(_) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::donate(_) => <donateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::extsload_0(_) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::extsload_1(_) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::extsload_2(_) => {
                    <extsload_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exttload_0(_) => {
                    <exttload_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exttload_1(_) => {
                    <exttload_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOperator(_) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::modifyLiquidity(_) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::protocolFeeController(_) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolFeesAccrued(_) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOperator(_) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolFee(_) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolFeeController(_) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::settle(_) => <settleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::settleFor(_) => {
                    <settleForCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::swap(_) => <swapCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sync(_) => <syncCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::take(_) => <takeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unlock(_) => <unlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateDynamicLPFee(_) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<PoolManagerCalls>] = &[
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::transfer)
                    }
                    transfer
                },
                {
                    fn take(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <takeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::take)
                    }
                    take
                },
                {
                    fn settle(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <settleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::settle)
                    }
                    settle
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::mint)
                    }
                    mint
                },
                {
                    fn extsload_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <extsload_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::extsload_0)
                    }
                    extsload_0
                },
                {
                    fn donate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <donateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::donate)
                    }
                    donate
                },
                {
                    fn setProtocolFeeController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::setProtocolFeeController)
                    }
                    setProtocolFeeController
                },
                {
                    fn extsload_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <extsload_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::extsload_1)
                    }
                    extsload_1
                },
                {
                    fn settleFor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <settleForCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::settleFor)
                    }
                    settleFor
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::approve)
                    }
                    approve
                },
                {
                    fn unlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <unlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::unlock)
                    }
                    unlock
                },
                {
                    fn updateDynamicLPFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::updateDynamicLPFee)
                    }
                    updateDynamicLPFee
                },
                {
                    fn setOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <setOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::setOperator)
                    }
                    setOperator
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::allowance)
                    }
                    allowance
                },
                {
                    fn modifyLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::modifyLiquidity)
                    }
                    modifyLiquidity
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn setProtocolFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::setProtocolFee)
                    }
                    setProtocolFee
                },
                {
                    fn clear(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <clearCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::clear)
                    }
                    clear
                },
                {
                    fn collectProtocolFees(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::collectProtocolFees)
                    }
                    collectProtocolFees
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn protocolFeesAccrued(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::protocolFeesAccrued)
                    }
                    protocolFeesAccrued
                },
                {
                    fn exttload_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <exttload_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::exttload_0)
                    }
                    exttload_0
                },
                {
                    fn sync(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <syncCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::sync)
                    }
                    sync
                },
                {
                    fn isOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <isOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::isOperator)
                    }
                    isOperator
                },
                {
                    fn extsload_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <extsload_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::extsload_2)
                    }
                    extsload_2
                },
                {
                    fn protocolFeeController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::protocolFeeController)
                    }
                    protocolFeeController
                },
                {
                    fn exttload_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <exttload_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::exttload_1)
                    }
                    exttload_1
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn swap(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <swapCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::swap)
                    }
                    swap
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::burn)
                    }
                    burn
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::transferFrom)
                    }
                    transferFrom
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::clear(inner) => {
                    <clearCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::collectProtocolFees(inner) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::donate(inner) => {
                    <donateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_2(inner) => {
                    <extsload_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exttload_0(inner) => {
                    <exttload_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exttload_1(inner) => {
                    <exttload_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::modifyLiquidity(inner) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::protocolFeeController(inner) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::protocolFeesAccrued(inner) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProtocolFee(inner) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProtocolFeeController(inner) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::settle(inner) => {
                    <settleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::settleFor(inner) => {
                    <settleForCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sync(inner) => {
                    <syncCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::take(inner) => {
                    <takeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unlock(inner) => {
                    <unlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateDynamicLPFee(inner) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::clear(inner) => {
                    <clearCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::collectProtocolFees(inner) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::donate(inner) => {
                    <donateCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::extsload_2(inner) => {
                    <extsload_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exttload_0(inner) => {
                    <exttload_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exttload_1(inner) => {
                    <exttload_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::modifyLiquidity(inner) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::protocolFeeController(inner) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::protocolFeesAccrued(inner) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProtocolFee(inner) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProtocolFeeController(inner) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::settle(inner) => {
                    <settleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::settleFor(inner) => {
                    <settleForCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sync(inner) => {
                    <syncCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::take(inner) => {
                    <takeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unlock(inner) => {
                    <unlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateDynamicLPFee(inner) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`PoolManager`](self) custom errors.
    pub enum PoolManagerErrors {
        AlreadyUnlocked(AlreadyUnlocked),
        CurrenciesOutOfOrderOrEqual(CurrenciesOutOfOrderOrEqual),
        CurrencyNotSettled(CurrencyNotSettled),
        DelegateCallNotAllowed(DelegateCallNotAllowed),
        InvalidCaller(InvalidCaller),
        ManagerLocked(ManagerLocked),
        MustClearExactPositiveDelta(MustClearExactPositiveDelta),
        NonzeroNativeValue(NonzeroNativeValue),
        PoolNotInitialized(PoolNotInitialized),
        ProtocolFeeCannotBeFetched(ProtocolFeeCannotBeFetched),
        ProtocolFeeTooLarge(ProtocolFeeTooLarge),
        SwapAmountCannotBeZero(SwapAmountCannotBeZero),
        TickSpacingTooLarge(TickSpacingTooLarge),
        TickSpacingTooSmall(TickSpacingTooSmall),
        UnauthorizedDynamicLPFeeUpdate(UnauthorizedDynamicLPFeeUpdate),
    }
    #[automatically_derived]
    impl PoolManagerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 137u8, 67u8, 142u8],
            [30u8, 228u8, 151u8, 2u8],
            [48u8, 210u8, 22u8, 65u8],
            [72u8, 106u8, 163u8, 7u8],
            [72u8, 245u8, 195u8, 237u8],
            [80u8, 144u8, 214u8, 198u8],
            [82u8, 18u8, 203u8, 161u8],
            [84u8, 227u8, 202u8, 13u8],
            [110u8, 108u8, 152u8, 48u8],
            [167u8, 171u8, 226u8, 247u8],
            [176u8, 236u8, 132u8, 158u8],
            [183u8, 0u8, 36u8, 248u8],
            [189u8, 167u8, 58u8, 191u8],
            [190u8, 139u8, 133u8, 7u8],
            [233u8, 233u8, 5u8, 136u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for PoolManagerErrors {
        const NAME: &'static str = "PoolManagerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 15usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyUnlocked(_) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CurrenciesOutOfOrderOrEqual(_) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CurrencyNotSettled(_) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DelegateCallNotAllowed(_) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCaller(_) => {
                    <InvalidCaller as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ManagerLocked(_) => {
                    <ManagerLocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MustClearExactPositiveDelta(_) => {
                    <MustClearExactPositiveDelta as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NonzeroNativeValue(_) => {
                    <NonzeroNativeValue as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PoolNotInitialized(_) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProtocolFeeCannotBeFetched(_) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProtocolFeeTooLarge(_) => {
                    <ProtocolFeeTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapAmountCannotBeZero(_) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TickSpacingTooLarge(_) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TickSpacingTooSmall(_) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedDynamicLPFeeUpdate(_) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<PoolManagerErrors>] = &[
                {
                    fn DelegateCallNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::DelegateCallNotAllowed)
                    }
                    DelegateCallNotAllowed
                },
                {
                    fn ProtocolFeeCannotBeFetched(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::ProtocolFeeCannotBeFetched)
                    }
                    ProtocolFeeCannotBeFetched
                },
                {
                    fn UnauthorizedDynamicLPFeeUpdate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::UnauthorizedDynamicLPFeeUpdate)
                    }
                    UnauthorizedDynamicLPFeeUpdate
                },
                {
                    fn PoolNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <PoolNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::PoolNotInitialized)
                    }
                    PoolNotInitialized
                },
                {
                    fn InvalidCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <InvalidCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::InvalidCaller)
                    }
                    InvalidCaller
                },
                {
                    fn AlreadyUnlocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <AlreadyUnlocked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::AlreadyUnlocked)
                    }
                    AlreadyUnlocked
                },
                {
                    fn CurrencyNotSettled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <CurrencyNotSettled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::CurrencyNotSettled)
                    }
                    CurrencyNotSettled
                },
                {
                    fn ManagerLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <ManagerLocked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::ManagerLocked)
                    }
                    ManagerLocked
                },
                {
                    fn CurrenciesOutOfOrderOrEqual(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::CurrenciesOutOfOrderOrEqual)
                    }
                    CurrenciesOutOfOrderOrEqual
                },
                {
                    fn ProtocolFeeTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <ProtocolFeeTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::ProtocolFeeTooLarge)
                    }
                    ProtocolFeeTooLarge
                },
                {
                    fn NonzeroNativeValue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <NonzeroNativeValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::NonzeroNativeValue)
                    }
                    NonzeroNativeValue
                },
                {
                    fn TickSpacingTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::TickSpacingTooLarge)
                    }
                    TickSpacingTooLarge
                },
                {
                    fn MustClearExactPositiveDelta(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <MustClearExactPositiveDelta as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::MustClearExactPositiveDelta)
                    }
                    MustClearExactPositiveDelta
                },
                {
                    fn SwapAmountCannotBeZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::SwapAmountCannotBeZero)
                    }
                    SwapAmountCannotBeZero
                },
                {
                    fn TickSpacingTooSmall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::TickSpacingTooSmall)
                    }
                    TickSpacingTooSmall
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyUnlocked(inner) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CurrenciesOutOfOrderOrEqual(inner) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CurrencyNotSettled(inner) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DelegateCallNotAllowed(inner) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidCaller(inner) => {
                    <InvalidCaller as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ManagerLocked(inner) => {
                    <ManagerLocked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::MustClearExactPositiveDelta(inner) => {
                    <MustClearExactPositiveDelta as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NonzeroNativeValue(inner) => {
                    <NonzeroNativeValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PoolNotInitialized(inner) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProtocolFeeCannotBeFetched(inner) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProtocolFeeTooLarge(inner) => {
                    <ProtocolFeeTooLarge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapAmountCannotBeZero(inner) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TickSpacingTooLarge(inner) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TickSpacingTooSmall(inner) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorizedDynamicLPFeeUpdate(inner) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyUnlocked(inner) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CurrenciesOutOfOrderOrEqual(inner) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CurrencyNotSettled(inner) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DelegateCallNotAllowed(inner) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCaller(inner) => {
                    <InvalidCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ManagerLocked(inner) => {
                    <ManagerLocked as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MustClearExactPositiveDelta(inner) => {
                    <MustClearExactPositiveDelta as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NonzeroNativeValue(inner) => {
                    <NonzeroNativeValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PoolNotInitialized(inner) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProtocolFeeCannotBeFetched(inner) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProtocolFeeTooLarge(inner) => {
                    <ProtocolFeeTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapAmountCannotBeZero(inner) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TickSpacingTooLarge(inner) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TickSpacingTooSmall(inner) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedDynamicLPFeeUpdate(inner) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`PoolManager`](self) events.
    pub enum PoolManagerEvents {
        Approval(Approval),
        Donate(Donate),
        Initialize(Initialize),
        ModifyLiquidity(ModifyLiquidity),
        OperatorSet(OperatorSet),
        OwnershipTransferred(OwnershipTransferred),
        ProtocolFeeControllerUpdated(ProtocolFeeControllerUpdated),
        ProtocolFeeUpdated(ProtocolFeeUpdated),
        Swap(Swap),
        Transfer(Transfer),
    }
    #[automatically_derived]
    impl PoolManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                27u8,
                61u8,
                126u8,
                219u8,
                46u8,
                156u8,
                11u8,
                14u8,
                124u8,
                82u8,
                91u8,
                32u8,
                170u8,
                174u8,
                240u8,
                245u8,
                148u8,
                13u8,
                46u8,
                215u8,
                22u8,
                99u8,
                199u8,
                211u8,
                146u8,
                102u8,
                236u8,
                175u8,
                172u8,
                114u8,
                136u8,
                89u8,
            ],
            [
                41u8,
                239u8,
                5u8,
                202u8,
                175u8,
                249u8,
                64u8,
                75u8,
                124u8,
                182u8,
                209u8,
                192u8,
                233u8,
                187u8,
                174u8,
                158u8,
                170u8,
                122u8,
                178u8,
                84u8,
                31u8,
                235u8,
                161u8,
                169u8,
                196u8,
                36u8,
                133u8,
                148u8,
                192u8,
                129u8,
                86u8,
                203u8,
            ],
            [
                64u8,
                233u8,
                206u8,
                203u8,
                159u8,
                95u8,
                31u8,
                28u8,
                91u8,
                156u8,
                151u8,
                222u8,
                194u8,
                145u8,
                123u8,
                126u8,
                233u8,
                46u8,
                87u8,
                186u8,
                85u8,
                99u8,
                112u8,
                141u8,
                172u8,
                169u8,
                77u8,
                216u8,
                74u8,
                215u8,
                17u8,
                47u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                179u8,
                253u8,
                80u8,
                113u8,
                131u8,
                88u8,
                135u8,
                86u8,
                122u8,
                6u8,
                113u8,
                21u8,
                17u8,
                33u8,
                137u8,
                77u8,
                220u8,
                204u8,
                40u8,
                66u8,
                241u8,
                209u8,
                11u8,
                237u8,
                173u8,
                19u8,
                224u8,
                209u8,
                124u8,
                172u8,
                233u8,
                167u8,
            ],
            [
                180u8,
                189u8,
                142u8,
                245u8,
                61u8,
                246u8,
                144u8,
                185u8,
                148u8,
                61u8,
                51u8,
                24u8,
                153u8,
                96u8,
                6u8,
                219u8,
                184u8,
                42u8,
                37u8,
                245u8,
                71u8,
                25u8,
                216u8,
                200u8,
                3u8,
                91u8,
                81u8,
                106u8,
                42u8,
                91u8,
                138u8,
                204u8,
            ],
            [
                206u8,
                181u8,
                118u8,
                217u8,
                241u8,
                94u8,
                78u8,
                32u8,
                15u8,
                219u8,
                80u8,
                150u8,
                214u8,
                77u8,
                93u8,
                253u8,
                102u8,
                126u8,
                22u8,
                222u8,
                242u8,
                12u8,
                30u8,
                239u8,
                209u8,
                66u8,
                86u8,
                216u8,
                227u8,
                250u8,
                162u8,
                103u8,
            ],
            [
                221u8,
                70u8,
                110u8,
                103u8,
                78u8,
                165u8,
                87u8,
                245u8,
                98u8,
                149u8,
                226u8,
                208u8,
                33u8,
                138u8,
                18u8,
                94u8,
                164u8,
                180u8,
                240u8,
                246u8,
                243u8,
                48u8,
                123u8,
                149u8,
                248u8,
                94u8,
                97u8,
                16u8,
                131u8,
                141u8,
                100u8,
                56u8,
            ],
            [
                233u8,
                196u8,
                37u8,
                147u8,
                231u8,
                31u8,
                132u8,
                64u8,
                59u8,
                132u8,
                53u8,
                44u8,
                209u8,
                104u8,
                214u8,
                147u8,
                226u8,
                201u8,
                252u8,
                209u8,
                253u8,
                188u8,
                195u8,
                254u8,
                178u8,
                29u8,
                146u8,
                180u8,
                62u8,
                102u8,
                150u8,
                249u8,
            ],
            [
                242u8,
                8u8,
                244u8,
                145u8,
                39u8,
                130u8,
                253u8,
                37u8,
                199u8,
                241u8,
                20u8,
                202u8,
                55u8,
                35u8,
                162u8,
                213u8,
                221u8,
                111u8,
                59u8,
                204u8,
                58u8,
                200u8,
                219u8,
                90u8,
                246u8,
                59u8,
                170u8,
                133u8,
                247u8,
                17u8,
                213u8,
                236u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for PoolManagerEvents {
        const NAME: &'static str = "PoolManagerEvents";
        const COUNT: usize = 10usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<Donate as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Donate as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Donate)
                }
                Some(<Initialize as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialize as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialize)
                }
                Some(<ModifyLiquidity as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ModifyLiquidity as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ModifyLiquidity)
                }
                Some(<OperatorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorSet)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <ProtocolFeeControllerUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProtocolFeeControllerUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ProtocolFeeControllerUpdated)
                }
                Some(
                    <ProtocolFeeUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProtocolFeeUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ProtocolFeeUpdated)
                }
                Some(<Swap as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Swap as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Swap)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for PoolManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Donate(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialize(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ModifyLiquidity(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolFeeControllerUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolFeeUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Swap(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Donate(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialize(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ModifyLiquidity(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolFeeControllerUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolFeeUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Swap(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`PoolManager`](self) contract instance.

See the [wrapper's documentation](`PoolManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> PoolManagerInstance<T, P, N> {
        PoolManagerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        controllerGasLimit: alloy::sol_types::private::U256,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<PoolManagerInstance<T, P, N>>,
    > {
        PoolManagerInstance::<T, P, N>::deploy(provider, controllerGasLimit)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        controllerGasLimit: alloy::sol_types::private::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        PoolManagerInstance::<T, P, N>::deploy_builder(provider, controllerGasLimit)
    }
    /**A [`PoolManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`PoolManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct PoolManagerInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for PoolManagerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("PoolManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolManagerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`PoolManager`](self) contract instance.

See the [wrapper's documentation](`PoolManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            controllerGasLimit: alloy::sol_types::private::U256,
        ) -> alloy_contract::Result<PoolManagerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, controllerGasLimit);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            controllerGasLimit: alloy::sol_types::private::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            controllerGasLimit,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> PoolManagerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> PoolManagerInstance<T, P, N> {
            PoolManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolManagerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(
                &allowanceCall {
                    owner,
                    spender,
                    id,
                },
            )
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, id, amount })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            owner: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { owner, id })
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            from: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { from, id, amount })
        }
        ///Creates a new call builder for the [`clear`] function.
        pub fn clear(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, clearCall, N> {
            self.call_builder(&clearCall { currency, amount })
        }
        ///Creates a new call builder for the [`collectProtocolFees`] function.
        pub fn collectProtocolFees(
            &self,
            recipient: alloy::sol_types::private::Address,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, collectProtocolFeesCall, N> {
            self.call_builder(
                &collectProtocolFeesCall {
                    recipient,
                    currency,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`donate`] function.
        pub fn donate(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            amount0: alloy::sol_types::private::U256,
            amount1: alloy::sol_types::private::U256,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, donateCall, N> {
            self.call_builder(
                &donateCall {
                    key,
                    amount0,
                    amount1,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`extsload_0`] function.
        pub fn extsload_0(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_0Call, N> {
            self.call_builder(&extsload_0Call { slot })
        }
        ///Creates a new call builder for the [`extsload_1`] function.
        pub fn extsload_1(
            &self,
            startSlot: alloy::sol_types::private::FixedBytes<32>,
            nSlots: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_1Call, N> {
            self.call_builder(
                &extsload_1Call {
                    startSlot,
                    nSlots,
                },
            )
        }
        ///Creates a new call builder for the [`extsload_2`] function.
        pub fn extsload_2(
            &self,
            slots: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_2Call, N> {
            self.call_builder(&extsload_2Call { slots })
        }
        ///Creates a new call builder for the [`exttload_0`] function.
        pub fn exttload_0(
            &self,
            slots: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, exttload_0Call, N> {
            self.call_builder(&exttload_0Call { slots })
        }
        ///Creates a new call builder for the [`exttload_1`] function.
        pub fn exttload_1(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, exttload_1Call, N> {
            self.call_builder(&exttload_1Call { slot })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            sqrtPriceX96: <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    key,
                    sqrtPriceX96,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`isOperator`] function.
        pub fn isOperator(
            &self,
            owner: alloy::sol_types::private::Address,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isOperatorCall, N> {
            self.call_builder(&isOperatorCall { owner, operator })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { to, id, amount })
        }
        ///Creates a new call builder for the [`modifyLiquidity`] function.
        pub fn modifyLiquidity(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            params: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, modifyLiquidityCall, N> {
            self.call_builder(
                &modifyLiquidityCall {
                    key,
                    params,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`protocolFeeController`] function.
        pub fn protocolFeeController(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, protocolFeeControllerCall, N> {
            self.call_builder(&protocolFeeControllerCall {})
        }
        ///Creates a new call builder for the [`protocolFeesAccrued`] function.
        pub fn protocolFeesAccrued(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, protocolFeesAccruedCall, N> {
            self.call_builder(
                &protocolFeesAccruedCall {
                    currency,
                },
            )
        }
        ///Creates a new call builder for the [`setOperator`] function.
        pub fn setOperator(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOperatorCall, N> {
            self.call_builder(
                &setOperatorCall {
                    operator,
                    approved,
                },
            )
        }
        ///Creates a new call builder for the [`setProtocolFee`] function.
        pub fn setProtocolFee(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            newProtocolFee: <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setProtocolFeeCall, N> {
            self.call_builder(
                &setProtocolFeeCall {
                    key,
                    newProtocolFee,
                },
            )
        }
        ///Creates a new call builder for the [`setProtocolFeeController`] function.
        pub fn setProtocolFeeController(
            &self,
            controller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setProtocolFeeControllerCall, N> {
            self.call_builder(
                &setProtocolFeeControllerCall {
                    controller,
                },
            )
        }
        ///Creates a new call builder for the [`settle`] function.
        pub fn settle(&self) -> alloy_contract::SolCallBuilder<T, &P, settleCall, N> {
            self.call_builder(&settleCall {})
        }
        ///Creates a new call builder for the [`settleFor`] function.
        pub fn settleFor(
            &self,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, settleForCall, N> {
            self.call_builder(&settleForCall { recipient })
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`swap`] function.
        pub fn swap(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            params: <SwapParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, swapCall, N> {
            self.call_builder(&swapCall { key, params, hookData })
        }
        ///Creates a new call builder for the [`sync`] function.
        pub fn sync(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, syncCall, N> {
            self.call_builder(&syncCall { currency })
        }
        ///Creates a new call builder for the [`take`] function.
        pub fn take(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, takeCall, N> {
            self.call_builder(&takeCall { currency, to, amount })
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            receiver: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(
                &transferCall {
                    receiver,
                    id,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            sender: alloy::sol_types::private::Address,
            receiver: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    sender,
                    receiver,
                    id,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unlock`] function.
        pub fn unlock(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, unlockCall, N> {
            self.call_builder(&unlockCall { data })
        }
        ///Creates a new call builder for the [`updateDynamicLPFee`] function.
        pub fn updateDynamicLPFee(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            newDynamicLPFee: <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateDynamicLPFeeCall, N> {
            self.call_builder(
                &updateDynamicLPFeeCall {
                    key,
                    newDynamicLPFee,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolManagerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`Donate`] event.
        pub fn Donate_filter(&self) -> alloy_contract::Event<T, &P, Donate, N> {
            self.event_filter::<Donate>()
        }
        ///Creates a new event filter for the [`Initialize`] event.
        pub fn Initialize_filter(&self) -> alloy_contract::Event<T, &P, Initialize, N> {
            self.event_filter::<Initialize>()
        }
        ///Creates a new event filter for the [`ModifyLiquidity`] event.
        pub fn ModifyLiquidity_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ModifyLiquidity, N> {
            self.event_filter::<ModifyLiquidity>()
        }
        ///Creates a new event filter for the [`OperatorSet`] event.
        pub fn OperatorSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorSet, N> {
            self.event_filter::<OperatorSet>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ProtocolFeeControllerUpdated`] event.
        pub fn ProtocolFeeControllerUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ProtocolFeeControllerUpdated, N> {
            self.event_filter::<ProtocolFeeControllerUpdated>()
        }
        ///Creates a new event filter for the [`ProtocolFeeUpdated`] event.
        pub fn ProtocolFeeUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ProtocolFeeUpdated, N> {
            self.event_filter::<ProtocolFeeUpdated>()
        }
        ///Creates a new event filter for the [`Swap`] event.
        pub fn Swap_filter(&self) -> alloy_contract::Event<T, &P, Swap, N> {
            self.event_filter::<Swap>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
